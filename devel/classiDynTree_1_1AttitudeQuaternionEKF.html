<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iDynTree: iDynTree::AttitudeQuaternionEKF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iDynTree
   </div>
   <div id="projectbrief">Free floating robots dynamics library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classiDynTree_1_1AttitudeQuaternionEKF.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classiDynTree_1_1AttitudeQuaternionEKF-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iDynTree::AttitudeQuaternionEKF Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Quaternion based Discrete Extended Kalman Filter fusing IMU measurements, to give estimates of orientation, angular velocity and gyroscope bias.  
 <a href="classiDynTree_1_1AttitudeQuaternionEKF.html#details">More...</a></p>

<p><code>#include &lt;AttitudeQuaternionEKF.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for iDynTree::AttitudeQuaternionEKF:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classiDynTree_1_1AttitudeQuaternionEKF__inherit__graph.svg" width="446" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for iDynTree::AttitudeQuaternionEKF:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classiDynTree_1_1AttitudeQuaternionEKF__coll__graph.svg" width="1298" height="235"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ac6c60831a6e6e7d725f4a0fccb89bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a6ac6c60831a6e6e7d725f4a0fccb89bd">AttitudeQuaternionEKF</a> ()</td></tr>
<tr class="separator:a6ac6c60831a6e6e7d725f4a0fccb89bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b3f1dfb973ce781b7419d563ba9034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a72b3f1dfb973ce781b7419d563ba9034">getParameters</a> (<a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html">AttitudeQuaternionEKFParameters</a> &amp;params)</td></tr>
<tr class="memdesc:a72b3f1dfb973ce781b7419d563ba9034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get filter parameters as a struct.  <a href="#a72b3f1dfb973ce781b7419d563ba9034">More...</a><br /></td></tr>
<tr class="separator:a72b3f1dfb973ce781b7419d563ba9034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7703c18de1dc271848bfd0dc0ac95e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a6e7703c18de1dc271848bfd0dc0ac95e">setParameters</a> (const <a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html">AttitudeQuaternionEKFParameters</a> &amp;params)</td></tr>
<tr class="memdesc:a6e7703c18de1dc271848bfd0dc0ac95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set filter parameters with the struct members.  <a href="#a6e7703c18de1dc271848bfd0dc0ac95e">More...</a><br /></td></tr>
<tr class="separator:a6e7703c18de1dc271848bfd0dc0ac95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1960e49e08ce5219426f88ed38d9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#aff1960e49e08ce5219426f88ed38d9ce">setGravityDirection</a> (const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> &amp;gravity_dir)</td></tr>
<tr class="memdesc:aff1960e49e08ce5219426f88ed38d9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the gravity direction assumed by the filter This affects the measurement model function h() and Jacobian H.  <a href="#aff1960e49e08ce5219426f88ed38d9ce">More...</a><br /></td></tr>
<tr class="separator:aff1960e49e08ce5219426f88ed38d9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f991f11a96c646dda00856e0c3f2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a56f991f11a96c646dda00856e0c3f2f8">setTimeStepInSeconds</a> (double time_step_in_seconds)</td></tr>
<tr class="memdesc:a56f991f11a96c646dda00856e0c3f2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set discretization time step in seconds  <a href="#a56f991f11a96c646dda00856e0c3f2f8">More...</a><br /></td></tr>
<tr class="separator:a56f991f11a96c646dda00856e0c3f2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeea4332a25849b1fd96708d6d7c42ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#afeea4332a25849b1fd96708d6d7c42ee">setBiasCorrelationTimeFactor</a> (double bias_correlation_time_factor)</td></tr>
<tr class="memdesc:afeea4332a25849b1fd96708d6d7c42ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">set bias correlation time factor  <a href="#afeea4332a25849b1fd96708d6d7c42ee">More...</a><br /></td></tr>
<tr class="separator:afeea4332a25849b1fd96708d6d7c42ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc3ebc4d6e60eb849b23ba32abd4a66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#adbc3ebc4d6e60eb849b23ba32abd4a66">useMagnetometerMeasurements</a> (bool use_magnetometer_measurements)</td></tr>
<tr class="memdesc:adbc3ebc4d6e60eb849b23ba32abd4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">set flag to use magnetometer measurements  <a href="#adbc3ebc4d6e60eb849b23ba32abd4a66">More...</a><br /></td></tr>
<tr class="separator:adbc3ebc4d6e60eb849b23ba32abd4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1246a70eb1035dfa8f2c6ff7d41b12c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a1246a70eb1035dfa8f2c6ff7d41b12c2">setMeasurementNoiseVariance</a> (double acc, double mag)</td></tr>
<tr class="memdesc:a1246a70eb1035dfa8f2c6ff7d41b12c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepares the measurement noise covariance matrix and calls ekfSetMeasurementNoiseMeanAndCovariance() measurement noise depends only on accelerometer xyz (and magnetometer z)  <a href="#a1246a70eb1035dfa8f2c6ff7d41b12c2">More...</a><br /></td></tr>
<tr class="separator:a1246a70eb1035dfa8f2c6ff7d41b12c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a0a22738cb1d87a14dea460a56b547"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a06a0a22738cb1d87a14dea460a56b547">setSystemNoiseVariance</a> (double gyro, double gyro_bias)</td></tr>
<tr class="memdesc:a06a0a22738cb1d87a14dea460a56b547"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepares the system noise covariance matrix and calls ekfSetSystemNoiseMeanAndCovariance() process noise depends on gyro measurement and gyro bias estimate - since gyro measurement is passed as input  <a href="#a06a0a22738cb1d87a14dea460a56b547">More...</a><br /></td></tr>
<tr class="separator:a06a0a22738cb1d87a14dea460a56b547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab359a33634ff3c1aa789cb1feb3169a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#ab359a33634ff3c1aa789cb1feb3169a4">setInitialStateCovariance</a> (double orientation_var, double ang_vel_var, double gyro_bias_var)</td></tr>
<tr class="memdesc:ab359a33634ff3c1aa789cb1feb3169a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepares the state covariance matrix and calls <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a557ecd035b2ff1e2267d3f98c0cf3a35" title="Set initial state covariance matrix the size of P and (state size*state size) should match...">ekfSetStateCovariance()</a>  <a href="#ab359a33634ff3c1aa789cb1feb3169a4">More...</a><br /></td></tr>
<tr class="separator:ab359a33634ff3c1aa789cb1feb3169a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c97d04ff819678edc75e694b02a8ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a97c97d04ff819678edc75e694b02a8ef">initializeFilter</a> ()</td></tr>
<tr class="memdesc:a97c97d04ff819678edc75e694b02a8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">intializes the filter by resizing buffers and setting parameters  <a href="#a97c97d04ff819678edc75e694b02a8ef">More...</a><br /></td></tr>
<tr class="separator:a97c97d04ff819678edc75e694b02a8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb65b053f2854685bb193318cfd5e6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#addb65b053f2854685bb193318cfd5e6c">updateFilterWithMeasurements</a> (const <a class="el" href="namespaceiDynTree.html#adcfa60b3d3580f517fd47c8864534b36">iDynTree::LinearAccelerometerMeasurements</a> &amp;linAccMeas, const <a class="el" href="namespaceiDynTree.html#a94dcb1f9c90a22269981469e229ed6ce">iDynTree::GyroscopeMeasurements</a> &amp;gyroMeas) override</td></tr>
<tr class="memdesc:addb65b053f2854685bb193318cfd5e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the filter with accelerometer and gyroscope measurements.  <a href="#addb65b053f2854685bb193318cfd5e6c">More...</a><br /></td></tr>
<tr class="separator:addb65b053f2854685bb193318cfd5e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066e3d8d073c3374c3c49cfc41bb4618"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a066e3d8d073c3374c3c49cfc41bb4618">updateFilterWithMeasurements</a> (const <a class="el" href="namespaceiDynTree.html#adcfa60b3d3580f517fd47c8864534b36">iDynTree::LinearAccelerometerMeasurements</a> &amp;linAccMeas, const <a class="el" href="namespaceiDynTree.html#a94dcb1f9c90a22269981469e229ed6ce">iDynTree::GyroscopeMeasurements</a> &amp;gyroMeas, const <a class="el" href="namespaceiDynTree.html#ad170eb4fd0bd13bfb0bdbdb6460d28bc">iDynTree::MagnetometerMeasurements</a> &amp;magMeas) override</td></tr>
<tr class="memdesc:a066e3d8d073c3374c3c49cfc41bb4618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the filter with accelerometer, gyroscope and magnetometer measurements.  <a href="#a066e3d8d073c3374c3c49cfc41bb4618">More...</a><br /></td></tr>
<tr class="separator:a066e3d8d073c3374c3c49cfc41bb4618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d06f0744427bd918a7175919176fa05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a6d06f0744427bd918a7175919176fa05">propagateStates</a> () override</td></tr>
<tr class="memdesc:a6d06f0744427bd918a7175919176fa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate the states and associated uncertainties through properly defined propagation functions The underlying implementation depends on the type of filter being implemented.  <a href="#a6d06f0744427bd918a7175919176fa05">More...</a><br /></td></tr>
<tr class="separator:a6d06f0744427bd918a7175919176fa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd7d6c689f0ff66d799469d0fd1dbf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a0fd7d6c689f0ff66d799469d0fd1dbf0">getOrientationEstimateAsRotationMatrix</a> (<a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;rot) override</td></tr>
<tr class="memdesc:a0fd7d6c689f0ff66d799469d0fd1dbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get orientation of the body with respect to inertial frame, in rotation matrix form If we denote \( A \) as inertial frame and \( B \) as the frame attached to the body, then this method gives us \( {^A}R_B \) as the rotation matrix.  <a href="#a0fd7d6c689f0ff66d799469d0fd1dbf0">More...</a><br /></td></tr>
<tr class="separator:a0fd7d6c689f0ff66d799469d0fd1dbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e03a0620f4abf473d8cf42c37528ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a01e03a0620f4abf473d8cf42c37528ea">getOrientationEstimateAsQuaternion</a> (<a class="el" href="namespaceiDynTree.html#a8953e202971beb38867767ab9f002c42">iDynTree::UnitQuaternion</a> &amp;q) override</td></tr>
<tr class="memdesc:a01e03a0620f4abf473d8cf42c37528ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get orientation of the body with respect to inertial frame, in unit quaternion form If we denote \( A \) as inertial frame and \( B \) as the frame attached to the body, then this method gives us \( {^A}q_B as the quaternion \).  <a href="#a01e03a0620f4abf473d8cf42c37528ea">More...</a><br /></td></tr>
<tr class="separator:a01e03a0620f4abf473d8cf42c37528ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc087b7d9adc7384e008c8dae11677b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a0fc087b7d9adc7384e008c8dae11677b">getOrientationEstimateAsRPY</a> (<a class="el" href="namespaceiDynTree.html#a48e2955e462d28103d57a10634d0654d">iDynTree::RPY</a> &amp;rpy) override</td></tr>
<tr class="memdesc:a0fc087b7d9adc7384e008c8dae11677b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get orientation of the body with respect to inertial frame, in Euler's RPY form If we denote \( A \) as inertial frame and \( B \) as the frame attached to the body, then this method gives us the RPY 3d vector of Euler Angles when composed together gives us \( {^A}R_B \) as the rotation matrix where \( {^A}R_B = Rot_z(yaw)Rot_y(pitch)Rot_x(roll)\).  <a href="#a0fc087b7d9adc7384e008c8dae11677b">More...</a><br /></td></tr>
<tr class="separator:a0fc087b7d9adc7384e008c8dae11677b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add647ea478071ebfc8d16a421c36f3ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#add647ea478071ebfc8d16a421c36f3ef">getInternalStateSize</a> () const override</td></tr>
<tr class="memdesc:add647ea478071ebfc8d16a421c36f3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get dimension of the state vector.  <a href="#add647ea478071ebfc8d16a421c36f3ef">More...</a><br /></td></tr>
<tr class="separator:add647ea478071ebfc8d16a421c36f3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5c9a6cc64d28e33bb5ccf424b6622"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a38b5c9a6cc64d28e33bb5ccf424b6622">getInternalState</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;stateBuffer) const override</td></tr>
<tr class="memdesc:a38b5c9a6cc64d28e33bb5ccf424b6622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get internal state of the estimator The internal state of the estimator is described as \( X = \begin{bmatrix} {^A}q_B \\ {^B}\Omega_{A,B} \\ {^B}b \end{bmatrix}^T \) \( {^A}q_B \in \mathbb{R}^4 \) is the quaternion representing the orientation of a body(IMU) frame with respect to an inertial frame , \( {^B}\Omega_{A,B} \in \mathbb{R}^3 \) is the angular velocity of a body(IMU) frame with respect to an inertial frame, expressed in the body frame and \( {^B}b \in \mathbb{R}^3 \) is the gyroscope bias expressed in the body frame.  <a href="#a38b5c9a6cc64d28e33bb5ccf424b6622">More...</a><br /></td></tr>
<tr class="separator:a38b5c9a6cc64d28e33bb5ccf424b6622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687b22236d1149388d9dae9bc3eed81f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a687b22236d1149388d9dae9bc3eed81f">getDefaultInternalInitialState</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;stateBuffer) const override</td></tr>
<tr class="memdesc:a687b22236d1149388d9dae9bc3eed81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get initial internal state of the estimator The internal state of the estimator is described as \( X = \begin{bmatrix} {^A}q_B \\ {^B}\Omega_{A,B} \\ {^B}b \end{bmatrix}^T \) \( {^A}q_B \in \mathbb{R}^4 \) is the quaternion representing the orientation of a body(IMU) frame with respect to an inertial frame , \( {^B}\Omega_{A,B} \in \mathbb{R}^3 \) is the angular velocity of a body(IMU) frame with respect to an inertial frame, expressed in the body frame and \( {^B}b \in \mathbb{R}^3 \) is the gyroscope bias expressed in the body frame.  <a href="#a687b22236d1149388d9dae9bc3eed81f">More...</a><br /></td></tr>
<tr class="separator:a687b22236d1149388d9dae9bc3eed81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c3440e43f4a09841e7aacb977fc5f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#af2c3440e43f4a09841e7aacb977fc5f6">setInternalState</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;stateBuffer) override</td></tr>
<tr class="memdesc:af2c3440e43f4a09841e7aacb977fc5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set internal state of the estimator.  <a href="#af2c3440e43f4a09841e7aacb977fc5f6">More...</a><br /></td></tr>
<tr class="separator:af2c3440e43f4a09841e7aacb977fc5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a6ab9ed9227c130dd6edc9fbe02e49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#aa7a6ab9ed9227c130dd6edc9fbe02e49">setInternalStateInitialOrientation</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;orientationBuffer) override</td></tr>
<tr class="memdesc:aa7a6ab9ed9227c130dd6edc9fbe02e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the initial orientation for the internal state of the estimator.  <a href="#aa7a6ab9ed9227c130dd6edc9fbe02e49">More...</a><br /></td></tr>
<tr class="separator:aa7a6ab9ed9227c130dd6edc9fbe02e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e0c6ab212f148079af396e0eb69244"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244">ekfPredict</a> ()</td></tr>
<tr class="memdesc:a06e0c6ab212f148079af396e0eb69244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Discrete EKF prediction equation described by \( \hat{x}_{k+1} = f(x_k, u_k) \) is given by the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#aa35db724dab6168cb3d84e44cbb809ea" title="Describes the state propagation for a given dynamical system If state of the system is denoted by  an...">ekf_f()</a> method \( \hat{P}_{k+1} = F_k P_k F_k^T + Q \) where, \( F \mid_{x = x_k} \) is given by the ekfComputejacobianF() method.  <a href="#a06e0c6ab212f148079af396e0eb69244">More...</a><br /></td></tr>
<tr class="separator:a06e0c6ab212f148079af396e0eb69244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3511ef7000edb1af2f22c750ac5ccb63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63">ekfUpdate</a> ()</td></tr>
<tr class="memdesc:a3511ef7000edb1af2f22c750ac5ccb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Discrete EKF update equation described by \( z_{k+1} = h(\hat{x}_{k+1}) \) is given by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a823fd6ec74999d302d6ba38322de1a82" title="Describes the measurement model of the system, i.e., how the measurements can be described as a funct...">ekf_h()</a> method innovation \( \tilde{y}_{k+1} = y_{k+1} - z_{k+1} \) innovation covariance \( S_{k+1} = H_{k+1} \hat{P}_{k+1} H_{k+1}^T + R \), where \( H \mid_{x = \hat{x}_{k+1}} \) is given by ekfComputejacobianH() method Kalman gain \( K_{k+1} = \hat{P}_{k+1} H_{k+1}^T S_{k+1}^{-1} \) Updated covariance \( P_{k+1} = \hat{P}_{k+1} - (K_{k+1} H \hat{P}_{k+1}) \) Updated state estimate \( x_{k+1} = \hat{x}_{k+1} + K_{k+1} \tilde{y}_{k+1} \).  <a href="#a3511ef7000edb1af2f22c750ac5ccb63">More...</a><br /></td></tr>
<tr class="separator:a3511ef7000edb1af2f22c750ac5ccb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37450d1833a7ce6d7b2caec4e00c9a62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62">ekfInit</a> ()</td></tr>
<tr class="memdesc:a37450d1833a7ce6d7b2caec4e00c9a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and resizes the internal buffers of this filter.  <a href="#a37450d1833a7ce6d7b2caec4e00c9a62">More...</a><br /></td></tr>
<tr class="separator:a37450d1833a7ce6d7b2caec4e00c9a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dda1a9c2249dc1d7d38dbc6da69b8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a48dda1a9c2249dc1d7d38dbc6da69b8b">ekfInit</a> (const size_t &amp;state_size, const size_t &amp;input_size, const size_t &amp;output_size)</td></tr>
<tr class="memdesc:a48dda1a9c2249dc1d7d38dbc6da69b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and resizes the internal buffers of this filter.  <a href="#a48dda1a9c2249dc1d7d38dbc6da69b8b">More...</a><br /></td></tr>
<tr class="separator:a48dda1a9c2249dc1d7d38dbc6da69b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236c419106fbe83a4651cdd8f28fb3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a236c419106fbe83a4651cdd8f28fb3f8">ekfReset</a> ()</td></tr>
<tr class="memdesc:a236c419106fbe83a4651cdd8f28fb3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the filter flags The filter flags check if the filter was properly initialized, if the initial state was set, if the initial state covariance was set.  <a href="#a236c419106fbe83a4651cdd8f28fb3f8">More...</a><br /></td></tr>
<tr class="separator:a236c419106fbe83a4651cdd8f28fb3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5980548288752504e9e4758b532e4c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a5980548288752504e9e4758b532e4c66">ekfReset</a> (const size_t &amp;state_size, const size_t &amp;input_size, const size_t &amp;output_size, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;x0, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;P0, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;Q, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;R)</td></tr>
<tr class="memdesc:a5980548288752504e9e4758b532e4c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the filter flags, initializes and resizes internal buffers of the filter, and sets initial state, initial state covariance, and system noise and measurement noise covariance matrices.  <a href="#a5980548288752504e9e4758b532e4c66">More...</a><br /></td></tr>
<tr class="separator:a5980548288752504e9e4758b532e4c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395b24fd4ae30bb88b35179ea80117cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb">ekfSetMeasurementVector</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;y)</td></tr>
<tr class="memdesc:a395b24fd4ae30bb88b35179ea80117cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set measurement vector at every time step the measurement vector size and output size should match.  <a href="#a395b24fd4ae30bb88b35179ea80117cb">More...</a><br /></td></tr>
<tr class="separator:a395b24fd4ae30bb88b35179ea80117cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ec69c3ded347027f494c84af300d45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45">ekfSetInputVector</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;u)</td></tr>
<tr class="memdesc:af2ec69c3ded347027f494c84af300d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set input vector at every time step the input vector size and input size should match.  <a href="#af2ec69c3ded347027f494c84af300d45">More...</a><br /></td></tr>
<tr class="separator:af2ec69c3ded347027f494c84af300d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc0fd06681f866166e527abf303929e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#abcc0fd06681f866166e527abf303929e">ekfSetInitialState</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;x0)</td></tr>
<tr class="memdesc:abcc0fd06681f866166e527abf303929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial state the size of x0 and state size should match.  <a href="#abcc0fd06681f866166e527abf303929e">More...</a><br /></td></tr>
<tr class="separator:abcc0fd06681f866166e527abf303929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557ecd035b2ff1e2267d3f98c0cf3a35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a557ecd035b2ff1e2267d3f98c0cf3a35">ekfSetStateCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;P)</td></tr>
<tr class="memdesc:a557ecd035b2ff1e2267d3f98c0cf3a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial state covariance matrix the size of P and (state size*state size) should match.  <a href="#a557ecd035b2ff1e2267d3f98c0cf3a35">More...</a><br /></td></tr>
<tr class="separator:a557ecd035b2ff1e2267d3f98c0cf3a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927eee549a560c68d95cbea5b0cec797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a927eee549a560c68d95cbea5b0cec797">ekfSetSystemNoiseCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;Q)</td></tr>
<tr class="memdesc:a927eee549a560c68d95cbea5b0cec797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set system noise covariance matrix the size of Q and (state size*state size) should match.  <a href="#a927eee549a560c68d95cbea5b0cec797">More...</a><br /></td></tr>
<tr class="separator:a927eee549a560c68d95cbea5b0cec797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1bd4ba94586c78c477a4a3af1fce0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a0d1bd4ba94586c78c477a4a3af1fce0b">ekfSetMeasurementNoiseCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;R)</td></tr>
<tr class="memdesc:a0d1bd4ba94586c78c477a4a3af1fce0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set measurement noise covariance matrix the size of R and (output size*output size) should match.  <a href="#a0d1bd4ba94586c78c477a4a3af1fce0b">More...</a><br /></td></tr>
<tr class="separator:a0d1bd4ba94586c78c477a4a3af1fce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a4ba3b26206d2607d724866e4bfd1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a">ekfSetStateSize</a> (size_t dim_X)</td></tr>
<tr class="memdesc:a47a4ba3b26206d2607d724866e4bfd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state dimensions.  <a href="#a47a4ba3b26206d2607d724866e4bfd1a">More...</a><br /></td></tr>
<tr class="separator:a47a4ba3b26206d2607d724866e4bfd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301ab496750472b1681d509e30c75da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1">ekfSetInputSize</a> (size_t dim_U)</td></tr>
<tr class="memdesc:a301ab496750472b1681d509e30c75da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input dimensions.  <a href="#a301ab496750472b1681d509e30c75da1">More...</a><br /></td></tr>
<tr class="separator:a301ab496750472b1681d509e30c75da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e0003290ca166251c7d8bb4a80162d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d">ekfSetOutputSize</a> (size_t dim_Y)</td></tr>
<tr class="memdesc:af8e0003290ca166251c7d8bb4a80162d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ouptut dimensions.  <a href="#af8e0003290ca166251c7d8bb4a80162d">More...</a><br /></td></tr>
<tr class="separator:af8e0003290ca166251c7d8bb4a80162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b41687186a840fdd1b15288339c51e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a46b41687186a840fdd1b15288339c51e">ekfGetStates</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;x) const</td></tr>
<tr class="memdesc:a46b41687186a840fdd1b15288339c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current internal state of the filter the size of x and state size should match.  <a href="#a46b41687186a840fdd1b15288339c51e">More...</a><br /></td></tr>
<tr class="separator:a46b41687186a840fdd1b15288339c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac546a68e8ee705927c5dd9b57eb11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a65ac546a68e8ee705927c5dd9b57eb11">ekfGetStateCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;P) const</td></tr>
<tr class="memdesc:a65ac546a68e8ee705927c5dd9b57eb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get state covariance matrix the size of P and (state size*state size) should match.  <a href="#a65ac546a68e8ee705927c5dd9b57eb11">More...</a><br /></td></tr>
<tr class="separator:a65ac546a68e8ee705927c5dd9b57eb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a540be21bdc4ec8636da39190df3a3157"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a540be21bdc4ec8636da39190df3a3157"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a540be21bdc4ec8636da39190df3a3157">ignore</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:a540be21bdc4ec8636da39190df3a3157"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template to ignore unused parameters  <a href="#a540be21bdc4ec8636da39190df3a3157">More...</a><br /></td></tr>
<tr class="separator:a540be21bdc4ec8636da39190df3a3157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aeba1557b81069aec88408f1d54b1ca9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiDynTree_1_1AttitudeEstimatorState.html">AttitudeEstimatorState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#aeba1557b81069aec88408f1d54b1ca9f">m_state_qekf</a></td></tr>
<tr class="separator:aeba1557b81069aec88408f1d54b1ca9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87de8c8b6ab893bee277896ff6f983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiDynTree_1_1AttitudeEstimatorState.html">AttitudeEstimatorState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a2f87de8c8b6ab893bee277896ff6f983">m_initial_state_qekf</a></td></tr>
<tr class="separator:a2f87de8c8b6ab893bee277896ff6f983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d8453c695937413e0f7885a87aad65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html">AttitudeQuaternionEKFParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#ad6d8453c695937413e0f7885a87aad65">m_params_qekf</a></td></tr>
<tr class="memdesc:ad6d8453c695937413e0f7885a87aad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct holding the QEKF parameters  <a href="#ad6d8453c695937413e0f7885a87aad65">More...</a><br /></td></tr>
<tr class="separator:ad6d8453c695937413e0f7885a87aad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Quaternion based Discrete Extended Kalman Filter fusing IMU measurements, to give estimates of orientation, angular velocity and gyroscope bias. </p>
<p>It follows the implementation detailed in <a href="https://wuecampus2.uni-wuerzburg.de/moodle/pluginfile.php/1109745/mod_resource/content/1/QEKF_Floatsat_WS16.pdf">Quaternion Based Extended Kalman Filter, slides by Michael Stohmeier</a> The filter is used to estimate the states \( X = \begin{bmatrix} {^A}q_B \\ {^B}\Omega_{A,B} \\ {^B}b \end{bmatrix}^T \) where \( {^A}q_B \in \mathbb{R}^4 \) is the quaternion representing the orientation of a body(IMU) frame with respect to an inertial frame , \( {^B}\Omega_{A,B} \in \mathbb{R}^3 \) is the angular velocity of a body(IMU) frame with respect to an inertial frame, expressed in the body frame and \( {^B}b \in \mathbb{R}^3 \) is the gyroscope bias expressed in the body frame. </p><dl class="section note"><dt>Note</dt><dd>: we will drop the subscripts and superscripts in the rest of the documentation for convenience</dd></dl>
<p>Discretized dynamics during the prediction step, </p><p class="formulaDsp">
\[ \hat{{x}}_{k+1} = \begin{bmatrix} q_{k} \otimes \text{exp}(\omega \Delta T) \\ y_{gyro_{k}} - b_{k} \\ (1 - \lambda_{b} \Delta t)b_k \end{bmatrix} \]
</p>
<p>Measurement model for accelerometer is given as, </p><p class="formulaDsp">
\[ h_{acc}(\hat{x}_{k+1}) = \begin{bmatrix} 2(q_1q_3 - q_0q_2) \\ 2(q_2q_3 - q_0q_1) \\ q_0^2 - q_1^2 - q_2^2 + q_3^2 \end{bmatrix} \]
</p>
<p> obtained from \( {^w}R_b^T e_3 \) of the assumed gravity direction.</p>
<p>Measurement model for magnetometer measurement is given as, </p><p class="formulaDsp">
\[ h_{mag}(\hat{x}_{k+1}) = atan2( 2(q_0q_3 + q_1q_2),1 - 2(q_2^2 + q_3^2) ) \]
</p>
<p>The linearized system propogation and measurement model is obtained by computing Jacobins F and H with respect to the state.</p>
<p>The zero mean, additive Gaussian noise can be set using the covariance matrices which will be used during predict and update steps.</p>
<p>The <a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a6d06f0744427bd918a7175919176fa05" title="Propagate the states and associated uncertainties through properly defined propagation functions The ...">propagateStates()</a> method is called to set the input vector for the EKF, then <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244" title="Implements the Discrete EKF prediction equation described by  is given by the ekf_f() method  where...">ekfPredict()</a> is called to propagate the state through the propagation function f() and propate the state covariance using the Jacobian F.</p>
<p>The <a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#addb65b053f2854685bb193318cfd5e6c" title="Update the filter with accelerometer and gyroscope measurements. ">updateFilterWithMeasurements()</a> is called to set the measurement vector for the EKF, and then ekfUpdate is used to correct the state estimate and its covariance using the measurement model function h() and the measurement Jacobian H.</p>
<p>The usage of the QEKF should follow the decribed procedure below,</p><ul>
<li>instantiate the filter</li>
<li>set parameters</li>
<li>call <a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a97c97d04ff819678edc75e694b02a8ef" title="intializes the filter by resizing buffers and setting parameters ">initializeFilter()</a> (this is necessary for resizing the buffers, the user should call this method after setting parameters)</li>
<li>use <a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#af2c3440e43f4a09841e7aacb977fc5f6" title="set internal state of the estimator. ">setInternalState()</a> to set initial state (The filter will throw an error, if this is not called atleast once, this enforces the user to set intial state)</li>
<li>Once initialized, the following filter methods can be run in a loop to get the orientation estimates,<ul>
<li><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a6d06f0744427bd918a7175919176fa05" title="Propagate the states and associated uncertainties through properly defined propagation functions The ...">propagateStates()</a> method to propagate the states and covariance</li>
<li><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#addb65b053f2854685bb193318cfd5e6c" title="Update the filter with accelerometer and gyroscope measurements. ">updateFilterWithMeasurements()</a> method to correct the predicted states and covariance</li>
<li><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#a38b5c9a6cc64d28e33bb5ccf424b6622" title="Get internal state of the estimator The internal state of the estimator is described as   is the quat...">getInternalState()</a> or getOrientationEstimate*() methods to get the entire state estimate or only the attitude estimated in desired representation</li>
</ul>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>calling the method <a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html#adbc3ebc4d6e60eb849b23ba32abd4a66" title="set flag to use magnetometer measurements ">useMagnetometerMeasurements()</a> while the estimator is running, will reset the filter, reinitialize the filter to resize buffers and sets the previous estiamted state as the inital state. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>calling other set parameter methods does not reset the filter, since they are not associated with changing the output dimensions </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ac6c60831a6e6e7d725f4a0fccb89bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac6c60831a6e6e7d725f4a0fccb89bd">&#9670;&nbsp;</a></span>AttitudeQuaternionEKF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynTree::AttitudeQuaternionEKF::AttitudeQuaternionEKF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a72b3f1dfb973ce781b7419d563ba9034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b3f1dfb973ce781b7419d563ba9034">&#9670;&nbsp;</a></span>getParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::AttitudeQuaternionEKF::getParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html">AttitudeQuaternionEKFParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get filter parameters as a struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">params</td><td>object of <a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html" title="set up the quaternion EKF ">AttitudeQuaternionEKFParameters</a> passed as reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e7703c18de1dc271848bfd0dc0ac95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7703c18de1dc271848bfd0dc0ac95e">&#9670;&nbsp;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::AttitudeQuaternionEKF::setParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html">AttitudeQuaternionEKFParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set filter parameters with the struct members. </p>
<p>This resets filter since it also calls useMagnetometerMeasurements(flag) (if the use_magnetometer_measurements flag has been toggled). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>object of <a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html" title="set up the quaternion EKF ">AttitudeQuaternionEKFParameters</a> passed as a const reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

</div>
</div>
<a id="aff1960e49e08ce5219426f88ed38d9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1960e49e08ce5219426f88ed38d9ce">&#9670;&nbsp;</a></span>setGravityDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::AttitudeQuaternionEKF::setGravityDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> &amp;&#160;</td>
          <td class="paramname"><em>gravity_dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the gravity direction assumed by the filter This affects the measurement model function h() and Jacobian H. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gravity_dir</td><td>gravity direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56f991f11a96c646dda00856e0c3f2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f991f11a96c646dda00856e0c3f2f8">&#9670;&nbsp;</a></span>setTimeStepInSeconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::AttitudeQuaternionEKF::setTimeStepInSeconds </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_step_in_seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set discretization time step in seconds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_step_in_seconds</td><td>time step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeea4332a25849b1fd96708d6d7c42ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeea4332a25849b1fd96708d6d7c42ee">&#9670;&nbsp;</a></span>setBiasCorrelationTimeFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::AttitudeQuaternionEKF::setBiasCorrelationTimeFactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bias_correlation_time_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set bias correlation time factor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bias_correlation_time_factor</td><td>time factor for bias evolution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbc3ebc4d6e60eb849b23ba32abd4a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc3ebc4d6e60eb849b23ba32abd4a66">&#9670;&nbsp;</a></span>useMagnetometerMeasurements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::useMagnetometerMeasurements </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_magnetometer_measurements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set flag to use magnetometer measurements </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">use_magnetometer_measurements</td><td>enable/disable magnetometer measurements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calling this method with the flag same as current flag value will not change anything, meanwhile a new flag setting will reset the filter, reinitialize the filter and set the previous state as filter's initial state and previous state covariance as filter's intial state covariance </dd></dl>

</div>
</div>
<a id="a1246a70eb1035dfa8f2c6ff7d41b12c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1246a70eb1035dfa8f2c6ff7d41b12c2">&#9670;&nbsp;</a></span>setMeasurementNoiseVariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::setMeasurementNoiseVariance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepares the measurement noise covariance matrix and calls ekfSetMeasurementNoiseMeanAndCovariance() measurement noise depends only on accelerometer xyz (and magnetometer z) </p>
<dl class="section note"><dt>Note</dt><dd>the noise has zero mean (basically passes a zero vector with covariance matrix) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">acc</td><td>variance for accelerometer measurements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mag</td><td>variance for magnetometer measurements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

</div>
</div>
<a id="a06a0a22738cb1d87a14dea460a56b547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a0a22738cb1d87a14dea460a56b547">&#9670;&nbsp;</a></span>setSystemNoiseVariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::setSystemNoiseVariance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gyro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gyro_bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepares the system noise covariance matrix and calls ekfSetSystemNoiseMeanAndCovariance() process noise depends on gyro measurement and gyro bias estimate - since gyro measurement is passed as input </p>
<dl class="section note"><dt>Note</dt><dd>the noise has zero mean (basically passes a zero vector with covariance matrix) measurement noise depends only on accelerometer xyz (and magnetometer z) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gyro</td><td>variance for gyroscope measurements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gyro_bias</td><td>variance for gyroscope bias estimates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

</div>
</div>
<a id="ab359a33634ff3c1aa789cb1feb3169a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab359a33634ff3c1aa789cb1feb3169a4">&#9670;&nbsp;</a></span>setInitialStateCovariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::setInitialStateCovariance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>orientation_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ang_vel_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gyro_bias_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepares the state covariance matrix and calls <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a557ecd035b2ff1e2267d3f98c0cf3a35" title="Set initial state covariance matrix the size of P and (state size*state size) should match...">ekfSetStateCovariance()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation_var</td><td>variance for intial orientation state estimate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ang_vel_var</td><td>variance for initial angular velocity state estimate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gyro_bias_var</td><td>variance for intial gyro bias state estimate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

</div>
</div>
<a id="a97c97d04ff819678edc75e694b02a8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c97d04ff819678edc75e694b02a8ef">&#9670;&nbsp;</a></span>initializeFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::initializeFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>intializes the filter by resizing buffers and setting parameters </p>
<ul>
<li>sets state, output and input dimensions for the ekf</li>
<li>resizes internal buffers</li>
<li>calls <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a></li>
<li>sets system noise, measurement noise and initial state covariance</li>
<li>if successful sets initialized flag to true <dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>
</li>
</ul>

</div>
</div>
<a id="addb65b053f2854685bb193318cfd5e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb65b053f2854685bb193318cfd5e6c">&#9670;&nbsp;</a></span>updateFilterWithMeasurements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::updateFilterWithMeasurements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceiDynTree.html#adcfa60b3d3580f517fd47c8864534b36">iDynTree::LinearAccelerometerMeasurements</a> &amp;&#160;</td>
          <td class="paramname"><em>linAccMeas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiDynTree.html#a94dcb1f9c90a22269981469e229ed6ce">iDynTree::GyroscopeMeasurements</a> &amp;&#160;</td>
          <td class="paramname"><em>gyroMeas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the filter with accelerometer and gyroscope measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linAccMeas</td><td>proper (body acceleration - gravity) classical acceleration of the origin of the body frame B expressed in frame B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gyroMeas</td><td>angular velocity of body frame B with respect to an inertial fram A, expressed in frame B</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>consider the current behavior of our system does not use magnetometer measurements and is calling this method to update measurements. Then, if we decide to turn the flag use_magnetometer_measurements to true, this will not guarantee that the magnetometer measurements will be used. The magnetometer measurements will be used only if we replace this function call with the other overlaoded function considering the magnetometer measurements.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a9c251ac717cbcfeb75a39fffd5a9b185">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a066e3d8d073c3374c3c49cfc41bb4618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066e3d8d073c3374c3c49cfc41bb4618">&#9670;&nbsp;</a></span>updateFilterWithMeasurements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::updateFilterWithMeasurements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceiDynTree.html#adcfa60b3d3580f517fd47c8864534b36">iDynTree::LinearAccelerometerMeasurements</a> &amp;&#160;</td>
          <td class="paramname"><em>linAccMeas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiDynTree.html#a94dcb1f9c90a22269981469e229ed6ce">iDynTree::GyroscopeMeasurements</a> &amp;&#160;</td>
          <td class="paramname"><em>gyroMeas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiDynTree.html#ad170eb4fd0bd13bfb0bdbdb6460d28bc">iDynTree::MagnetometerMeasurements</a> &amp;&#160;</td>
          <td class="paramname"><em>magMeas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the filter with accelerometer, gyroscope and magnetometer measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linAccMeas</td><td>proper (body acceleration - gravity) classical acceleration of the origin of the body frame B expressed in frame B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gyroMeas</td><td>angular velocity of body frame B with respect to an inertial fram A, expressed in frame B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">magMeas</td><td>magnetometer measurements expressed in frame B</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a7121acf85b46be0edb9231588c579013">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a6d06f0744427bd918a7175919176fa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d06f0744427bd918a7175919176fa05">&#9670;&nbsp;</a></span>propagateStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::propagateStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Propagate the states and associated uncertainties through properly defined propagation functions The underlying implementation depends on the type of filter being implemented. </p>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a6cc4ea7bacb721c67890ceb250857e71">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a0fd7d6c689f0ff66d799469d0fd1dbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd7d6c689f0ff66d799469d0fd1dbf0">&#9670;&nbsp;</a></span>getOrientationEstimateAsRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::getOrientationEstimateAsRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>rot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get orientation of the body with respect to inertial frame, in rotation matrix form If we denote \( A \) as inertial frame and \( B \) as the frame attached to the body, then this method gives us \( {^A}R_B \) as the rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rot</td><td><a class="el" href="classiDynTree_1_1Rotation.html" title="Class representation the rotation of an orientation frame with respect to a reference orientation fra...">Rotation</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a3fd8541c4ede713177058251aae24717">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a01e03a0620f4abf473d8cf42c37528ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e03a0620f4abf473d8cf42c37528ea">&#9670;&nbsp;</a></span>getOrientationEstimateAsQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::getOrientationEstimateAsQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiDynTree.html#a8953e202971beb38867767ab9f002c42">iDynTree::UnitQuaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get orientation of the body with respect to inertial frame, in unit quaternion form If we denote \( A \) as inertial frame and \( B \) as the frame attached to the body, then this method gives us \( {^A}q_B as the quaternion \). </p>
<dl class="section note"><dt>Note</dt><dd>quaternion has the form (real, imaginary) and is normalized </dd>
<dd>
Usually a rotation matrix can be described using two quaternions due to its double-connectedness property Depending on the specific filter, the initial state and the trajectory of the system, we could obtain one quaternion or the other(opposite spin), depending on the system dynamics.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>UnitQuaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a72f94711e28d7173869f41492d6ac364">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a0fc087b7d9adc7384e008c8dae11677b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc087b7d9adc7384e008c8dae11677b">&#9670;&nbsp;</a></span>getOrientationEstimateAsRPY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::getOrientationEstimateAsRPY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiDynTree.html#a48e2955e462d28103d57a10634d0654d">iDynTree::RPY</a> &amp;&#160;</td>
          <td class="paramname"><em>rpy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get orientation of the body with respect to inertial frame, in Euler's RPY form If we denote \( A \) as inertial frame and \( B \) as the frame attached to the body, then this method gives us the RPY 3d vector of Euler Angles when composed together gives us \( {^A}R_B \) as the rotation matrix where \( {^A}R_B = Rot_z(yaw)Rot_y(pitch)Rot_x(roll)\). </p>
<p>For more details about the range of the RPY Euler angles, please refer the documentation of <a href="https://github.com/robotology/idyntree/blob/c8bf721b771fa4b1e7c3a940632e121060719a19/src/core/include/iDynTree/Core/Rotation.h#L167">GetRPY()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rpy</td><td>3D vector containing roll pitch yaw angles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#add5b1c7109a232bcb3da976792f72a6f">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="add647ea478071ebfc8d16a421c36f3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add647ea478071ebfc8d16a421c36f3ef">&#9670;&nbsp;</a></span>getInternalStateSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t iDynTree::AttitudeQuaternionEKF::getInternalStateSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get dimension of the state vector. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t size of state vector </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a7234eb151268d99d90dbe691a6bf3a46">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a38b5c9a6cc64d28e33bb5ccf424b6622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b5c9a6cc64d28e33bb5ccf424b6622">&#9670;&nbsp;</a></span>getInternalState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::getInternalState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>stateBuffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get internal state of the estimator The internal state of the estimator is described as \( X = \begin{bmatrix} {^A}q_B \\ {^B}\Omega_{A,B} \\ {^B}b \end{bmatrix}^T \) \( {^A}q_B \in \mathbb{R}^4 \) is the quaternion representing the orientation of a body(IMU) frame with respect to an inertial frame , \( {^B}\Omega_{A,B} \in \mathbb{R}^3 \) is the angular velocity of a body(IMU) frame with respect to an inertial frame, expressed in the body frame and \( {^B}b \in \mathbb{R}^3 \) is the gyroscope bias expressed in the body frame. </p>
<p>The default internal state of the estimator would be \( X = \begin{bmatrix} 1.0 \\ 0_{1 \times 3} \\ 0_{1 \times 3} \\ 0_{1 \times 3} \end{bmatrix}^T \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stateBuffer</td><td><a class="el" href="classiDynTree_1_1Span.html">Span</a> object as reference of the container where state vector should be copied to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a0360685bed94e086224b1126116dca04">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a687b22236d1149388d9dae9bc3eed81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687b22236d1149388d9dae9bc3eed81f">&#9670;&nbsp;</a></span>getDefaultInternalInitialState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::getDefaultInternalInitialState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>stateBuffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get initial internal state of the estimator The internal state of the estimator is described as \( X = \begin{bmatrix} {^A}q_B \\ {^B}\Omega_{A,B} \\ {^B}b \end{bmatrix}^T \) \( {^A}q_B \in \mathbb{R}^4 \) is the quaternion representing the orientation of a body(IMU) frame with respect to an inertial frame , \( {^B}\Omega_{A,B} \in \mathbb{R}^3 \) is the angular velocity of a body(IMU) frame with respect to an inertial frame, expressed in the body frame and \( {^B}b \in \mathbb{R}^3 \) is the gyroscope bias expressed in the body frame. </p>
<p>The default internal state of the estimator would be \( X = \begin{bmatrix} 1.0 \\ 0_{1 \times 3} \\ 0_{1 \times 3} \\ 0_{1 \times 3} \end{bmatrix}^T \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stateBuffer</td><td><a class="el" href="classiDynTree_1_1Span.html">Span</a> object as reference of the container where state vector should be copied to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a86554ddcfc70601b05ad7cd997851983">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="af2c3440e43f4a09841e7aacb977fc5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c3440e43f4a09841e7aacb977fc5f6">&#9670;&nbsp;</a></span>setInternalState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::setInternalState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>stateBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set internal state of the estimator. </p>
<p>The internal state of the estimator is described as \( X = \begin{bmatrix} {^A}q_B \\ {^B}\Omega_{A,B} \\ {^B}b \end{bmatrix}^T \) \( {^A}q_B \in \mathbb{R}^4 \) is the quaternion representing the orientation of a body(IMU) frame with respect to an inertial frame , \( {^B}\Omega_{A,B} \in \mathbb{R}^3 \) is the angular velocity of a body(IMU) frame with respect to an inertial frame, expressed in the body frame and \( {^B}b \in \mathbb{R}^3 \) is the gyroscope bias expressed in the body frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stateBuffer</td><td><a class="el" href="classiDynTree_1_1Span.html">Span</a> object as reference of the container from which the internal state vector should be assigned. The size of the buffer should be 10. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a4277465fc6cacfa0fa0ccd1d1c863954">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="aa7a6ab9ed9227c130dd6edc9fbe02e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a6ab9ed9227c130dd6edc9fbe02e49">&#9670;&nbsp;</a></span>setInternalStateInitialOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::AttitudeQuaternionEKF::setInternalStateInitialOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientationBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the initial orientation for the internal state of the estimator. </p>
<p>The initial orientation for the internal state of the estimator is described as \( {^A}q_B \) \( {^A}q_B \in \mathbb{R}^4 \) is the quaternion representing the orientation of a body(IMU) frame with respect to an inertial frame , </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stateBuffer</td><td><a class="el" href="classiDynTree_1_1Span.html">Span</a> object as reference of the container from which the inital orientaiton for internal state vector should be assigned. The size of the buffer should be 4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false if successful/not </dd></dl>

<p>Implements <a class="el" href="classiDynTree_1_1IAttitudeEstimator.html#a8ca76def98fa0bd37975788dc7e1c0c5">iDynTree::IAttitudeEstimator</a>.</p>

</div>
</div>
<a id="a06e0c6ab212f148079af396e0eb69244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e0c6ab212f148079af396e0eb69244">&#9670;&nbsp;</a></span>ekfPredict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfPredict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the Discrete EKF prediction equation described by \( \hat{x}_{k+1} = f(x_k, u_k) \) is given by the ekf_f() method \( \hat{P}_{k+1} = F_k P_k F_k^T + Q \) where, \( F \mid_{x = x_k} \) is given by the ekfComputejacobianF() method. </p>
<dl class="section warning"><dt>Warning</dt><dd>this function can be called only after setting up the filter properly through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> step </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function should be once called every step, after setting up the input vector using <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45" title="Set input vector at every time step the input vector size and input size should match. ">ekfSetInputVector()</a> method </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>setting up the input vector everytime before calling the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244" title="Implements the Discrete EKF prediction equation described by  is given by the ekf_f() method  where...">ekfPredict()</a> method is crucial, the prediction step is not performed if this step is skipped this is because internally a flag associated to the setting up of input vector is set true by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45" title="Set input vector at every time step the input vector size and input size should match. ">ekfSetInputVector()</a> method which in turn is set false by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244" title="Implements the Discrete EKF prediction equation described by  is given by the ekf_f() method  where...">ekfPredict()</a> method </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>
<p>&lt; \( \hat{x}_{k+1} = f(x_k, u_k) \)</p>
<p>&lt; \( F \mid_{x = x_k} \)</p>
<p>&lt; \( \hat{P}_{k+1} = F_k P_k F_k^T + Q \) </p>

</div>
</div>
<a id="a3511ef7000edb1af2f22c750ac5ccb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3511ef7000edb1af2f22c750ac5ccb63">&#9670;&nbsp;</a></span>ekfUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the Discrete EKF update equation described by \( z_{k+1} = h(\hat{x}_{k+1}) \) is given by ekf_h() method innovation \( \tilde{y}_{k+1} = y_{k+1} - z_{k+1} \) innovation covariance \( S_{k+1} = H_{k+1} \hat{P}_{k+1} H_{k+1}^T + R \), where \( H \mid_{x = \hat{x}_{k+1}} \) is given by ekfComputejacobianH() method Kalman gain \( K_{k+1} = \hat{P}_{k+1} H_{k+1}^T S_{k+1}^{-1} \) Updated covariance \( P_{k+1} = \hat{P}_{k+1} - (K_{k+1} H \hat{P}_{k+1}) \) Updated state estimate \( x_{k+1} = \hat{x}_{k+1} + K_{k+1} \tilde{y}_{k+1} \). </p>
<dl class="section warning"><dt>Warning</dt><dd>this function can be called only after setting up the filter properly through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> step </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function should be once called every step, after setting up the measurement vector using <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb" title="Set measurement vector at every time step the measurement vector size and output size should match...">ekfSetMeasurementVector()</a> method </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>setting up the measurement vector everytime before calling the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63" title="Implements the Discrete EKF update equation described by  is given by ekf_h() method innovation  inno...">ekfUpdate()</a> method is crucial, the update step is not performed if this step is skipped this is because internally a flag associated to the setting up of measurement vector is set true by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb" title="Set measurement vector at every time step the measurement vector size and output size should match...">ekfSetMeasurementVector()</a> method which in turn is set false by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63" title="Implements the Discrete EKF update equation described by  is given by ekf_h() method innovation  inno...">ekfUpdate()</a> method </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>
<p>&lt; \( z_{k+1} = h(\hat{x}_{k+1}) \)</p>
<p>&lt; \( H \mid_{x = \hat{x}_{k+1}} \)</p>
<p>&lt; innovation \( \tilde{y}_{k+1} = y_{k+1} - z_{k+1} \)</p>
<p>&lt; \( S_{k+1} = H_{k+1} \hat{P}_{k+1} H_{k+1}^T + R \)</p>
<p>&lt; \( K_{k+1} = \hat{P}_{k+1} H_{k+1}^T S_{k+1}^{-1} \)</p>
<p>&lt; \( P_{k+1} = \hat{P}_{k+1} - (K_{k+1} H \hat{P}_{k+1}) \)</p>
<p>&lt; \( x_{k+1} = \hat{x}_{k+1} + K_{k+1} \tilde{y}_{k+1} \) </p>

</div>
</div>
<a id="a37450d1833a7ce6d7b2caec4e00c9a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37450d1833a7ce6d7b2caec4e00c9a62">&#9670;&nbsp;</a></span>ekfInit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes and resizes the internal buffers of this filter. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is a very crucial method of this class. This needs to be called after setting the input size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1" title="Set the input dimensions. ">ekfSetInputSize()</a>, output size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d" title="Set the ouptut dimensions. ">ekfSetOutputSize()</a> and state dimension through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a" title="Set the state dimensions. ">ekfSetStateSize()</a>, such that the corresponding matrices and vectors will resize themselves to their corresponding dimensions. Failing to do so might result in memory leaks and may cause the program to crash </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a48dda1a9c2249dc1d7d38dbc6da69b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dda1a9c2249dc1d7d38dbc6da69b8b">&#9670;&nbsp;</a></span>ekfInit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfInit </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>state_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>input_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>output_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes and resizes the internal buffers of this filter. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is a very crucial method of this class. This method sets the input size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1" title="Set the input dimensions. ">ekfSetInputSize()</a>, output size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d" title="Set the ouptut dimensions. ">ekfSetOutputSize()</a> and state dimension through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a" title="Set the state dimensions. ">ekfSetStateSize()</a> with the specified parameters, such that the corresponding matrices and vectors will resize themselves to their corresponding dimensions. Failing to do so might result in memory leaks and may cause the program to crash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state_size</td><td>state size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_size</td><td>input size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_size</td><td>output size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a236c419106fbe83a4651cdd8f28fb3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236c419106fbe83a4651cdd8f28fb3f8">&#9670;&nbsp;</a></span>ekfReset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the filter flags The filter flags check if the filter was properly initialized, if the initial state was set, if the initial state covariance was set. </p>
<p>These three flags are crucial for proper setting up of the filter. The other flags include the checks on whether the input and measurement vectors were updated at every prediction/update step </p>

</div>
</div>
<a id="a5980548288752504e9e4758b532e4c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5980548288752504e9e4758b532e4c66">&#9670;&nbsp;</a></span>ekfReset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfReset </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>state_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>input_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the filter flags, initializes and resizes internal buffers of the filter, and sets initial state, initial state covariance, and system noise and measurement noise covariance matrices. </p>
<dl class="section warning"><dt>Warning</dt><dd>size of the span for P0 and Q must be of the size (state size*state size), where * is the regular multiplication operator </dd>
<dd>
size of the span for R must be of the size (ouput size*output size), where * is the regular multiplication operator </dd>
<dd>
the matrices from the span are built in row-major ordering.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this method is particularly useful while working with hybrid systems, where the size of the system state or the measurements keep evolving with time </dd></dl>

</div>
</div>
<a id="a395b24fd4ae30bb88b35179ea80117cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395b24fd4ae30bb88b35179ea80117cb">&#9670;&nbsp;</a></span>ekfSetMeasurementVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetMeasurementVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set measurement vector at every time step the measurement vector size and output size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the measurement vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="af2ec69c3ded347027f494c84af300d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ec69c3ded347027f494c84af300d45">&#9670;&nbsp;</a></span>ekfSetInputVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetInputVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set input vector at every time step the input vector size and input size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="abcc0fd06681f866166e527abf303929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc0fd06681f866166e527abf303929e">&#9670;&nbsp;</a></span>ekfSetInitialState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetInitialState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set initial state the size of x0 and state size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method should be called before running the filter </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a557ecd035b2ff1e2267d3f98c0cf3a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557ecd035b2ff1e2267d3f98c0cf3a35">&#9670;&nbsp;</a></span>ekfSetStateCovariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetStateCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set initial state covariance matrix the size of P and (state size*state size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the state covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method should be called before running the filter </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if this matrix is not initialized properly, then the resulting output will only have NaNs in it </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a927eee549a560c68d95cbea5b0cec797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927eee549a560c68d95cbea5b0cec797">&#9670;&nbsp;</a></span>ekfSetSystemNoiseCovariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetSystemNoiseCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set system noise covariance matrix the size of Q and (state size*state size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the system noise covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>default value is a zero matrix </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a0d1bd4ba94586c78c477a4a3af1fce0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1bd4ba94586c78c477a4a3af1fce0b">&#9670;&nbsp;</a></span>ekfSetMeasurementNoiseCovariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetMeasurementNoiseCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set measurement noise covariance matrix the size of R and (output size*output size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the measurement noise covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>default value is a zero matrix </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a47a4ba3b26206d2607d724866e4bfd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a4ba3b26206d2607d724866e4bfd1a">&#9670;&nbsp;</a></span>ekfSetStateSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetStateSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the state dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_X</td><td>state size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this method should be called before calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a301ab496750472b1681d509e30c75da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301ab496750472b1681d509e30c75da1">&#9670;&nbsp;</a></span>ekfSetInputSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetInputSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the input dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_U</td><td>input size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this method should be called before calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="af8e0003290ca166251c7d8bb4a80162d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e0003290ca166251c7d8bb4a80162d">&#9670;&nbsp;</a></span>ekfSetOutputSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetOutputSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_Y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the ouptut dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_Y</td><td>output size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this method should be called before calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a46b41687186a840fdd1b15288339c51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b41687186a840fdd1b15288339c51e">&#9670;&nbsp;</a></span>ekfGetStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfGetStates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current internal state of the filter the size of x and state size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to copy the internal state vector into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a65ac546a68e8ee705927c5dd9b57eb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ac546a68e8ee705927c5dd9b57eb11">&#9670;&nbsp;</a></span>ekfGetStateCovariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfGetStateCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get state covariance matrix the size of P and (state size*state size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to copy the internal state covariance matrix onto </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a540be21bdc4ec8636da39190df3a3157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540be21bdc4ec8636da39190df3a3157">&#9670;&nbsp;</a></span>ignore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ignore </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function template to ignore unused parameters </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aeba1557b81069aec88408f1d54b1ca9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba1557b81069aec88408f1d54b1ca9f">&#9670;&nbsp;</a></span>m_state_qekf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiDynTree_1_1AttitudeEstimatorState.html">AttitudeEstimatorState</a> iDynTree::AttitudeQuaternionEKF::m_state_qekf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f87de8c8b6ab893bee277896ff6f983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f87de8c8b6ab893bee277896ff6f983">&#9670;&nbsp;</a></span>m_initial_state_qekf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiDynTree_1_1AttitudeEstimatorState.html">AttitudeEstimatorState</a> iDynTree::AttitudeQuaternionEKF::m_initial_state_qekf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6d8453c695937413e0f7885a87aad65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d8453c695937413e0f7885a87aad65">&#9670;&nbsp;</a></span>m_params_qekf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiDynTree_1_1AttitudeQuaternionEKFParameters.html">AttitudeQuaternionEKFParameters</a> iDynTree::AttitudeQuaternionEKF::m_params_qekf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>struct holding the QEKF parameters </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="AttitudeQuaternionEKF_8h.html">AttitudeQuaternionEKF.h</a></li>
<li><a class="el" href="AttitudeQuaternionEKF_8cpp.html">AttitudeQuaternionEKF.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiDynTree.html">iDynTree</a></li><li class="navelem"><a class="el" href="classiDynTree_1_1AttitudeQuaternionEKF.html">AttitudeQuaternionEKF</a></li>
    <li class="footer">Generated on Fri Jan 10 2020 08:54:56 for iDynTree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
