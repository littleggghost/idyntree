<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iDynTree: iDynTree::InverseKinematics Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iDynTree
   </div>
   <div id="projectbrief">Free floating robots dynamics library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classiDynTree_1_1InverseKinematics.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classiDynTree_1_1InverseKinematics-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iDynTree::InverseKinematics Class Reference<div class="ingroups"><a class="el" href="group__iDynTreeExperimental.html">Experimental classes, for which the interface is currently under active development and is not stable.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>NLP-based Inverse kinematics.  
 <a href="classiDynTree_1_1InverseKinematics.html#details">More...</a></p>

<p><code>#include &lt;InverseKinematics.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c7549b37f43c5fdf07cac67aaf0ca87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a2c7549b37f43c5fdf07cac67aaf0ca87">InverseKinematics</a> ()</td></tr>
<tr class="separator:a2c7549b37f43c5fdf07cac67aaf0ca87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9e4d4db2a590dad2f6b530b159cd06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a0d9e4d4db2a590dad2f6b530b159cd06">~InverseKinematics</a> ()</td></tr>
<tr class="separator:a0d9e4d4db2a590dad2f6b530b159cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e893981cbfa2afc88a231d1cace9a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ac3e893981cbfa2afc88a231d1cace9a4">loadModelFromFile</a> (const std::string &amp;filename, const std::vector&lt; std::string &gt; &amp;consideredJoints=std::vector&lt; std::string &gt;(), const std::string &amp;filetype=&quot;urdf&quot;)</td></tr>
<tr class="memdesc:ac3e893981cbfa2afc88a231d1cace9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the kinematic model from an external file.  <a href="#ac3e893981cbfa2afc88a231d1cace9a4">More...</a><br /></td></tr>
<tr class="separator:ac3e893981cbfa2afc88a231d1cace9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9706235b5fe16f951731ba285582ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#abb9706235b5fe16f951731ba285582ae">setModel</a> (const <a class="el" href="classiDynTree_1_1Model.html">iDynTree::Model</a> &amp;<a class="el" href="classiDynTree_1_1InverseKinematics.html#a6dce3f3bfd9f50334386ba1470c3f53f">model</a>, const std::vector&lt; std::string &gt; &amp;consideredJoints=std::vector&lt; std::string &gt;())</td></tr>
<tr class="memdesc:abb9706235b5fe16f951731ba285582ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the kinematic model to be used in the optimization  <a href="#abb9706235b5fe16f951731ba285582ae">More...</a><br /></td></tr>
<tr class="separator:abb9706235b5fe16f951731ba285582ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e7d22dbc79871a62a0ba4c6e79fb97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#aa6e7d22dbc79871a62a0ba4c6e79fb97">setJointLimits</a> (std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;jointLimits)</td></tr>
<tr class="separator:aa6e7d22dbc79871a62a0ba4c6e79fb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad4371be984af63072d7f7ffa1f79ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a1ad4371be984af63072d7f7ffa1f79ca">getJointLimits</a> (std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;jointLimits)</td></tr>
<tr class="separator:a1ad4371be984af63072d7f7ffa1f79ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d54045ad46403179e3cd3c076802978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a1d54045ad46403179e3cd3c076802978">clearProblem</a> ()</td></tr>
<tr class="separator:a1d54045ad46403179e3cd3c076802978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238847f4a1308b661cdf14ac4d10caf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a238847f4a1308b661cdf14ac4d10caf7">setFloatingBaseOnFrameNamed</a> (const std::string &amp;floatingBaseFrameName)</td></tr>
<tr class="separator:a238847f4a1308b661cdf14ac4d10caf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dda0ba095c33f702c52fee2312d628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a37dda0ba095c33f702c52fee2312d628">setRobotConfiguration</a> (const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;baseConfiguration, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;jointConfiguration)</td></tr>
<tr class="separator:a37dda0ba095c33f702c52fee2312d628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed57acc6905dcaeb4596c46ab6d7a47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a4ed57acc6905dcaeb4596c46ab6d7a47">setCurrentRobotConfiguration</a> (const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;baseConfiguration, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;jointConfiguration)</td></tr>
<tr class="separator:a4ed57acc6905dcaeb4596c46ab6d7a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321cd9fba3a93857acbf81ee7ce89d6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a321cd9fba3a93857acbf81ee7ce89d6f">setJointConfiguration</a> (const std::string &amp;jointName, const double jointConfiguration)</td></tr>
<tr class="separator:a321cd9fba3a93857acbf81ee7ce89d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3be372eb31516aeb39e3e0a6ae8724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a1f3be372eb31516aeb39e3e0a6ae8724">setRotationParametrization</a> (enum <a class="el" href="namespaceiDynTree.html#a04da5add9479687cf4c7eb873e717c6c">InverseKinematicsRotationParametrization</a> parametrization)</td></tr>
<tr class="separator:a1f3be372eb31516aeb39e3e0a6ae8724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f3902ff47fbafeb219c2e22529857d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespaceiDynTree.html#a04da5add9479687cf4c7eb873e717c6c">InverseKinematicsRotationParametrization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a16f3902ff47fbafeb219c2e22529857d">rotationParametrization</a> ()</td></tr>
<tr class="separator:a16f3902ff47fbafeb219c2e22529857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9003fa17de9f6467b127bc2809dd10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#aff9003fa17de9f6467b127bc2809dd10">setDesiredJointConfiguration</a> (const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;desiredJointConfiguration, double weight=-1.0)</td></tr>
<tr class="separator:aff9003fa17de9f6467b127bc2809dd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30597bf9cef5da3d0c30118a1c132a2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a30597bf9cef5da3d0c30118a1c132a2c">setDesiredFullJointsConfiguration</a> (const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;desiredJointConfiguration, double weight=-1.0)</td></tr>
<tr class="separator:a30597bf9cef5da3d0c30118a1c132a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c9eede82cbe551388baceed52240ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a50c9eede82cbe551388baceed52240ee">setDesiredFullJointsConfiguration</a> (const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;desiredJointConfiguration, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;weights)</td></tr>
<tr class="separator:a50c9eede82cbe551388baceed52240ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22154b11fa87fbb0be902f85e4a4a37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#af22154b11fa87fbb0be902f85e4a4a37">setDesiredReducedJointConfiguration</a> (const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;desiredJointConfiguration, double weight=-1.0)</td></tr>
<tr class="separator:af22154b11fa87fbb0be902f85e4a4a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084dff57455232ec11cfe81f9888eda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ae084dff57455232ec11cfe81f9888eda">setDesiredReducedJointConfiguration</a> (const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;desiredJointConfiguration, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;weights)</td></tr>
<tr class="separator:ae084dff57455232ec11cfe81f9888eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e61084a8305a1d089add9bff5a632ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a4e61084a8305a1d089add9bff5a632ea">setInitialCondition</a> (const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> *baseTransform, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> *initialCondition)</td></tr>
<tr class="separator:a4e61084a8305a1d089add9bff5a632ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79edd849ba6eb8d0b549cad3c9c00106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a79edd849ba6eb8d0b549cad3c9c00106">setFullJointsInitialCondition</a> (const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> *baseTransform, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> *initialCondition)</td></tr>
<tr class="separator:a79edd849ba6eb8d0b549cad3c9c00106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16eec79ccbccf5a180d46e874712e53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#af16eec79ccbccf5a180d46e874712e53">setReducedInitialCondition</a> (const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> *baseTransform, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> *initialCondition)</td></tr>
<tr class="separator:af16eec79ccbccf5a180d46e874712e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d51059431c6fed8e83983379e143d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#af4d51059431c6fed8e83983379e143d3">solve</a> ()</td></tr>
<tr class="separator:af4d51059431c6fed8e83983379e143d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672ccd4e2c30ac0ebbff58146ded4a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#af672ccd4e2c30ac0ebbff58146ded4a9">getPoseForFrame</a> (const std::string &amp;frameName, <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;<a class="el" href="namespaceiDynTree.html#a0e83d0ebf209d66127c738d02f6cc458">transform</a>)</td></tr>
<tr class="separator:af672ccd4e2c30ac0ebbff58146ded4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dce3f3bfd9f50334386ba1470c3f53f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classiDynTree_1_1Model.html">Model</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a6dce3f3bfd9f50334386ba1470c3f53f">model</a> () const</td></tr>
<tr class="separator:a6dce3f3bfd9f50334386ba1470c3f53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6ef09da0cb4ddb68261529a45f3f2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classiDynTree_1_1Model.html">Model</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a1a6ef09da0cb4ddb68261529a45f3f2f">fullModel</a> () const</td></tr>
<tr class="separator:a1a6ef09da0cb4ddb68261529a45f3f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e07ce1aea19321ecdaaaa8dcb0a84"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classiDynTree_1_1Model.html">Model</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a880e07ce1aea19321ecdaaaa8dcb0a84">reducedModel</a> () const</td></tr>
<tr class="separator:a880e07ce1aea19321ecdaaaa8dcb0a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176c4c0e2471a8af391e7b156b04a2b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a176c4c0e2471a8af391e7b156b04a2b0">setCOMTarget</a> (<a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;desiredPosition, double weight=1.0)</td></tr>
<tr class="separator:a176c4c0e2471a8af391e7b156b04a2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557041738a620f4ce2ef433083b9b3a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a557041738a620f4ce2ef433083b9b3a0">setCOMAsConstraint</a> (bool asConstraint=true)</td></tr>
<tr class="separator:a557041738a620f4ce2ef433083b9b3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2776f60ee744d261552c5685bec170f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ab2776f60ee744d261552c5685bec170f">setCOMAsConstraintTolerance</a> (double tolerance=1e-8)</td></tr>
<tr class="separator:ab2776f60ee744d261552c5685bec170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2d97dd6ed312e557fbee2a5d91e313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#acc2d97dd6ed312e557fbee2a5d91e313">isCOMAConstraint</a> ()</td></tr>
<tr class="separator:acc2d97dd6ed312e557fbee2a5d91e313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20284b4e939d67add4a1a90bba06dc0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a20284b4e939d67add4a1a90bba06dc0c">isCOMTargetActive</a> ()</td></tr>
<tr class="separator:a20284b4e939d67add4a1a90bba06dc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae834df2d99d5332143bb3ab617ea54e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ae834df2d99d5332143bb3ab617ea54e7">deactivateCOMTarget</a> ()</td></tr>
<tr class="separator:ae834df2d99d5332143bb3ab617ea54e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a77ce138803d1db8f2db9f1927034de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a9a77ce138803d1db8f2db9f1927034de">setCOMConstraintProjectionDirection</a> (<a class="el" href="namespaceiDynTree.html#a6ba91315448cf1d275f460097e36d134">iDynTree::Vector3</a> direction)</td></tr>
<tr class="separator:a9a77ce138803d1db8f2db9f1927034de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameters-related methods</div></td></tr>
<tr class="memitem:abd8b70a018553ec30f0998092ea28c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#abd8b70a018553ec30f0998092ea28c62">setMaxIterations</a> (const int max_iter)</td></tr>
<tr class="memdesc:abd8b70a018553ec30f0998092ea28c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Maximum Iteration.  <a href="#abd8b70a018553ec30f0998092ea28c62">More...</a><br /></td></tr>
<tr class="separator:abd8b70a018553ec30f0998092ea28c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1534f0883aa48bbd7396fb03ab9cc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a2e1534f0883aa48bbd7396fb03ab9cc3">maxIterations</a> () const</td></tr>
<tr class="memdesc:a2e1534f0883aa48bbd7396fb03ab9cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current value of Maximum Iteration.  <a href="#a2e1534f0883aa48bbd7396fb03ab9cc3">More...</a><br /></td></tr>
<tr class="separator:a2e1534f0883aa48bbd7396fb03ab9cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fbd05f09b0fa2d7f98af110992dd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a94fbd05f09b0fa2d7f98af110992dd02">setMaxCPUTime</a> (const double max_cpu_time)</td></tr>
<tr class="memdesc:a94fbd05f09b0fa2d7f98af110992dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Maximum CPU seconds.  <a href="#a94fbd05f09b0fa2d7f98af110992dd02">More...</a><br /></td></tr>
<tr class="separator:a94fbd05f09b0fa2d7f98af110992dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022f8652423611388707ad40ca71205"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a7022f8652423611388707ad40ca71205">maxCPUTime</a> () const</td></tr>
<tr class="memdesc:a7022f8652423611388707ad40ca71205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current value of Maximum CPU seconds.  <a href="#a7022f8652423611388707ad40ca71205">More...</a><br /></td></tr>
<tr class="separator:a7022f8652423611388707ad40ca71205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972eaa443d246d15a411b8b0c5e70a62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a972eaa443d246d15a411b8b0c5e70a62">setCostTolerance</a> (const double tol)</td></tr>
<tr class="memdesc:a972eaa443d246d15a411b8b0c5e70a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets cost function tolerance.  <a href="#a972eaa443d246d15a411b8b0c5e70a62">More...</a><br /></td></tr>
<tr class="separator:a972eaa443d246d15a411b8b0c5e70a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902ce28213d60568f68456511f57493e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a902ce28213d60568f68456511f57493e">costTolerance</a> () const</td></tr>
<tr class="memdesc:a902ce28213d60568f68456511f57493e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves cost function tolerance.  <a href="#a902ce28213d60568f68456511f57493e">More...</a><br /></td></tr>
<tr class="separator:a902ce28213d60568f68456511f57493e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963881a6913d92c4a224b68af44918fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a963881a6913d92c4a224b68af44918fb">setConstraintsTolerance</a> (const double constr_tol)</td></tr>
<tr class="memdesc:a963881a6913d92c4a224b68af44918fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets constraints tolerance.  <a href="#a963881a6913d92c4a224b68af44918fb">More...</a><br /></td></tr>
<tr class="separator:a963881a6913d92c4a224b68af44918fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431451fac26b849ab7b9157170926461"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a431451fac26b849ab7b9157170926461">constraintsTolerance</a> () const</td></tr>
<tr class="memdesc:a431451fac26b849ab7b9157170926461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves constraints tolerance.  <a href="#a431451fac26b849ab7b9157170926461">More...</a><br /></td></tr>
<tr class="separator:a431451fac26b849ab7b9157170926461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd58eaeec333ffe4a8b1cf68f48199a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a7fd58eaeec333ffe4a8b1cf68f48199a">setVerbosity</a> (const unsigned int verbose)</td></tr>
<tr class="separator:a7fd58eaeec333ffe4a8b1cf68f48199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c65c3b6ecb3b1de2cf84b319dbcca0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a79c65c3b6ecb3b1de2cf84b319dbcca0">linearSolverName</a> ()</td></tr>
<tr class="separator:a79c65c3b6ecb3b1de2cf84b319dbcca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45198b610d4f871a7fd0ed8b5b66846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#af45198b610d4f871a7fd0ed8b5b66846">setLinearSolverName</a> (const std::string &amp;solverName)</td></tr>
<tr class="separator:af45198b610d4f871a7fd0ed8b5b66846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constraints-related methods</div></td></tr>
<tr class="memitem:a7e721cd49fb9d2910dab79677a3febc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a7e721cd49fb9d2910dab79677a3febc0">addFrameConstraint</a> (const std::string &amp;frameName)</td></tr>
<tr class="separator:a7e721cd49fb9d2910dab79677a3febc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32732917055324e9e43b665f10d6d89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ad32732917055324e9e43b665f10d6d89">addFrameConstraint</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;constraintValue)</td></tr>
<tr class="separator:ad32732917055324e9e43b665f10d6d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8247e588e7c6a6caf37a52345c58a2a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a8247e588e7c6a6caf37a52345c58a2a3">addFramePositionConstraint</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;constraintValue)</td></tr>
<tr class="separator:a8247e588e7c6a6caf37a52345c58a2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08094142e67312af1c8dc6d43fcc5c54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a08094142e67312af1c8dc6d43fcc5c54">addFramePositionConstraint</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;constraintValue)</td></tr>
<tr class="separator:a08094142e67312af1c8dc6d43fcc5c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2581274da87dbf2b9cf8a8d1c34184fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a2581274da87dbf2b9cf8a8d1c34184fb">addFrameRotationConstraint</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;constraintValue)</td></tr>
<tr class="separator:a2581274da87dbf2b9cf8a8d1c34184fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053a41c48598e472cfc5acb69a707810"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a053a41c48598e472cfc5acb69a707810">addFrameRotationConstraint</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;constraintValue)</td></tr>
<tr class="separator:a053a41c48598e472cfc5acb69a707810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2da211d3d7091ad07a0b384b3ff48d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a2e2da211d3d7091ad07a0b384b3ff48d">activateFrameConstraint</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">Transform</a> &amp;newConstraintValue)</td></tr>
<tr class="separator:a2e2da211d3d7091ad07a0b384b3ff48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71611b4b312177be7c3682164742304a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a71611b4b312177be7c3682164742304a">deactivateFrameConstraint</a> (const std::string &amp;frameName)</td></tr>
<tr class="separator:a71611b4b312177be7c3682164742304a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762635dbe437ce96d4e5e597267be87d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a762635dbe437ce96d4e5e597267be87d">isFrameConstraintActive</a> (const std::string &amp;frameName) const</td></tr>
<tr class="separator:a762635dbe437ce96d4e5e597267be87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42335e61bf9fcb4fb62a7d48904e517"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#af42335e61bf9fcb4fb62a7d48904e517">addCenterOfMassProjectionConstraint</a> (const std::string &amp;firstSupportFrame, const <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &amp;firstSupportPolygon, const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> xAxisOfPlaneInWorld, const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> yAxisOfPlaneInWorld, const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> originOfPlaneInWorld=<a class="el" href="classiDynTree_1_1Position.html#aee87490c47a300dd487d35bef3ce4a1e">iDynTree::Position::Zero</a>())</td></tr>
<tr class="separator:af42335e61bf9fcb4fb62a7d48904e517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdeb6bdba32b5b98f8942bd73bdf70c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a9bdeb6bdba32b5b98f8942bd73bdf70c">addCenterOfMassProjectionConstraint</a> (const std::string &amp;firstSupportFrame, const <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &amp;firstSupportPolygon, const std::string &amp;secondSupportFrame, const <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &amp;secondSupportPolygon, const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> xAxisOfPlaneInWorld, const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> yAxisOfPlaneInWorld, const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> originOfPlaneInWorld=<a class="el" href="classiDynTree_1_1Position.html#aee87490c47a300dd487d35bef3ce4a1e">iDynTree::Position::Zero</a>())</td></tr>
<tr class="separator:a9bdeb6bdba32b5b98f8942bd73bdf70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7509e262a0293039b0ca99daf6344d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a5b7509e262a0293039b0ca99daf6344d">addCenterOfMassProjectionConstraint</a> (const std::vector&lt; std::string &gt; &amp;supportFrames, const std::vector&lt; <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &gt; &amp;supportPolygons, const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> xAxisOfPlaneInWorld, const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a> yAxisOfPlaneInWorld, const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> originOfPlaneInWorld)</td></tr>
<tr class="separator:a5b7509e262a0293039b0ca99daf6344d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab430e2a8abbea4b7b02fc7535109ad9f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ab430e2a8abbea4b7b02fc7535109ad9f">getCenterOfMassProjectionMargin</a> ()</td></tr>
<tr class="separator:ab430e2a8abbea4b7b02fc7535109ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e3692826f3c14bc9d0948285451bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a30e3692826f3c14bc9d0948285451bfa">getCenterOfMassProjectConstraintConvexHull</a> (<a class="el" href="classiDynTree_1_1Polygon2D.html">Polygon2D</a> &amp;convexHull)</td></tr>
<tr class="memdesc:a30e3692826f3c14bc9d0948285451bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active convex hull.  <a href="#a30e3692826f3c14bc9d0948285451bfa">More...</a><br /></td></tr>
<tr class="separator:a30e3692826f3c14bc9d0948285451bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Target-related methods</div></td></tr>
<tr class="memitem:af97c2d5f44b64f7e422e70d20c0d49c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#af97c2d5f44b64f7e422e70d20c0d49c9">addTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;targetValue, const double positionWeight=1.0, const double rotationWeight=1.0)</td></tr>
<tr class="separator:af97c2d5f44b64f7e422e70d20c0d49c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9571f744198e189b3635cf18b01fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a9f9571f744198e189b3635cf18b01fa6">addPositionTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;targetValue, const double positionWeight=1.0)</td></tr>
<tr class="separator:a9f9571f744198e189b3635cf18b01fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43517efef7345effef2c64ed792293d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a43517efef7345effef2c64ed792293d6">addPositionTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;targetValue, const double positionWeight=1.0)</td></tr>
<tr class="separator:a43517efef7345effef2c64ed792293d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8c88ba1c622755f8f6060d7c23f1b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#aed8c88ba1c622755f8f6060d7c23f1b0">addRotationTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;targetValue, const double rotationWeight=1.0)</td></tr>
<tr class="separator:aed8c88ba1c622755f8f6060d7c23f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef054698a036960b0cd9c4201553adee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#aef054698a036960b0cd9c4201553adee">addRotationTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;targetValue, const double rotationWeight=1.0)</td></tr>
<tr class="separator:aef054698a036960b0cd9c4201553adee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc04477ad6b4db5fe0ed87eaec33a366"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#afc04477ad6b4db5fe0ed87eaec33a366">updateTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;targetValue, const double positionWeight=-1.0, const double rotationWeight=-1.0)</td></tr>
<tr class="separator:afc04477ad6b4db5fe0ed87eaec33a366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242d903b37077336e8a7401390968e6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a242d903b37077336e8a7401390968e6c">updatePositionTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;targetValue, const double positionWeight=-1.0)</td></tr>
<tr class="separator:a242d903b37077336e8a7401390968e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d99a353d47eae1b831969affc69a38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a39d99a353d47eae1b831969affc69a38">updateRotationTarget</a> (const std::string &amp;frameName, const <a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;targetValue, const double rotationWeight=-1.0)</td></tr>
<tr class="separator:a39d99a353d47eae1b831969affc69a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55e7751070535950a098125d6064d46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ac55e7751070535950a098125d6064d46">setDefaultTargetResolutionMode</a> (enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">iDynTree::InverseKinematicsTreatTargetAsConstraint</a> mode)</td></tr>
<tr class="separator:ac55e7751070535950a098125d6064d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2c44f94a48893d064e90c3400e593d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">iDynTree::InverseKinematicsTreatTargetAsConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ada2c44f94a48893d064e90c3400e593d">defaultTargetResolutionMode</a> ()</td></tr>
<tr class="separator:ada2c44f94a48893d064e90c3400e593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c0473418948bdaeb1b002ff167e550"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a40c0473418948bdaeb1b002ff167e550">setTargetResolutionMode</a> (const std::string &amp;targetName, enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">InverseKinematicsTreatTargetAsConstraint</a> mode)</td></tr>
<tr class="separator:a40c0473418948bdaeb1b002ff167e550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dff5d4891a60e0aeb2c8c66c25c43a"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">InverseKinematicsTreatTargetAsConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#ae5dff5d4891a60e0aeb2c8c66c25c43a">targetResolutionMode</a> (const std::string &amp;frameName)</td></tr>
<tr class="separator:ae5dff5d4891a60e0aeb2c8c66c25c43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solution-related methods</div></td></tr>
<tr class="memitem:aa5251d7fd8b862b7b69278bbaf41e5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#aa5251d7fd8b862b7b69278bbaf41e5b8">getSolution</a> (<a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;baseTransformSolution, <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;shapeSolution)</td></tr>
<tr class="separator:aa5251d7fd8b862b7b69278bbaf41e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b937b35239f7b262391961f4c448ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a82b937b35239f7b262391961f4c448ea">getFullJointsSolution</a> (<a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;baseTransformSolution, <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;shapeSolution)</td></tr>
<tr class="separator:a82b937b35239f7b262391961f4c448ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe2c9cd84677f6dfd83fdc31e6e39e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1InverseKinematics.html#a0fe2c9cd84677f6dfd83fdc31e6e39e6">getReducedSolution</a> (<a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;baseTransformSolution, <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;shapeSolution)</td></tr>
<tr class="separator:a0fe2c9cd84677f6dfd83fdc31e6e39e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NLP-based Inverse kinematics. </p>
<p>Given a mechanical structure configuration </p><p class="formulaDsp">
\[ q \in SE(3) \times \mathbb{R}^n \]
</p>
<p> and possibly multiple target frames </p><p class="formulaDsp">
\[ F_i^d \in \SE(3) \]
</p>
<p> the inverse kinematics is responsible to find the configuration \( q^* \) such that </p><p class="formulaDsp">
\[ F_i(q^*) = F_i^d \forall i, \]
</p>
<p> where the meaning of the \(=\) and \(\forall\) depends on the resolution mode and on the references specified</p>
<p>Example </p><div class="fragment"><div class="line"><span class="comment">//Allocate an inverse kinematics object</span></div><div class="line">iDynTree::InverseKinematric ik;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>all the cartesian frames must be specified w.r.t. the same global frame. This library does not assume any particular global frame</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This class is still in active development, and so API interface can change between <a class="el" href="namespaceiDynTree.html">iDynTree</a> versions. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2c7549b37f43c5fdf07cac67aaf0ca87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7549b37f43c5fdf07cac67aaf0ca87">&#9670;&nbsp;</a></span>InverseKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynTree::InverseKinematics::InverseKinematics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor </p>

</div>
</div>
<a id="a0d9e4d4db2a590dad2f6b530b159cd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9e4d4db2a590dad2f6b530b159cd06">&#9670;&nbsp;</a></span>~InverseKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynTree::InverseKinematics::~InverseKinematics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac3e893981cbfa2afc88a231d1cace9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e893981cbfa2afc88a231d1cace9a4">&#9670;&nbsp;</a></span>loadModelFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::loadModelFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>consideredJoints</em> = <code>std::vector&lt;std::string&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filetype</em> = <code>&quot;urdf&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the kinematic model from an external file. </p>
<p>You can specify an optional list specifying which joints are considered as optimization variables (all the joints not contained in the list are considered fixed joint). If the vector is empty all the joints in the model will be considered as optimization variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">urdfFile</td><td>path to the urdf file describing the model </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">consideredJoints</td><td>list of internal joints describing which joints are optimized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filetype</td><td>(optional) explicit definition of the type of the loaded file. Only "urdf" is supported at the moment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. False otherwise </dd></dl>

</div>
</div>
<a id="abb9706235b5fe16f951731ba285582ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9706235b5fe16f951731ba285582ae">&#9670;&nbsp;</a></span>setModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Model.html">iDynTree::Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>consideredJoints</em> = <code>std::vector&lt;std::string&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the kinematic model to be used in the optimization </p>
<p>All the degrees of freedom listed in the second parameters will be used as optimization variables. If the vector is empty, all the joints will be used.</p>
<dl class="section note"><dt>Note</dt><dd>you may want to simplify the model by calling loadReducedModelFromFullModel method contained in the <a class="el" href="classiDynTree_1_1ModelLoader.html" title="Helper class to load a model from a generic format. ">ModelLoader</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>the kinematic model to be used in the optimization </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. False otherwise </dd></dl>

</div>
</div>
<a id="aa6e7d22dbc79871a62a0ba4c6e79fb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e7d22dbc79871a62a0ba4c6e79fb97">&#9670;&nbsp;</a></span>setJointLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setJointLimits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>jointLimits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set new joint limits </p><dl class="section author"><dt>Author</dt><dd>Yue Hu </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jointLimits</td><td>vector of new joint limits to be imposed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfull, false otherwise </dd></dl>

</div>
</div>
<a id="a1ad4371be984af63072d7f7ffa1f79ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad4371be984af63072d7f7ffa1f79ca">&#9670;&nbsp;</a></span>getJointLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::getJointLimits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>jointLimits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current joint limits </p><dl class="section author"><dt>Author</dt><dd>Yue Hu </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jointLimits</td><td>vector of current joint limits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfull, false otherwise </dd></dl>

</div>
</div>
<a id="a1d54045ad46403179e3cd3c076802978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d54045ad46403179e3cd3c076802978">&#9670;&nbsp;</a></span>clearProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::clearProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the variables. </p><dl class="section note"><dt>Note</dt><dd>the model is not removed </dd>
<dd>
The parameters such as max iterations, max cpu time and verbosity are resetted with this method. </dd></dl>

</div>
</div>
<a id="a238847f4a1308b661cdf14ac4d10caf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238847f4a1308b661cdf14ac4d10caf7">&#9670;&nbsp;</a></span>setFloatingBaseOnFrameNamed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setFloatingBaseOnFrameNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>floatingBaseFrameName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37dda0ba095c33f702c52fee2312d628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dda0ba095c33f702c52fee2312d628">&#9670;&nbsp;</a></span>setRobotConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setRobotConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>baseConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>jointConfiguration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the robot current configuration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseConfiguration</td><td>transformation identifying the base pose with respect to the world frame </td></tr>
    <tr><td class="paramname">robotConfiguration</td><td>the robot configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the size (and order) of jointConfiguration must match the joints in the model, not in the consideredJoints variable</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a4ed57acc6905dcaeb4596c46ab6d7a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed57acc6905dcaeb4596c46ab6d7a47">&#9670;&nbsp;</a></span>setCurrentRobotConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setCurrentRobotConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>baseConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>jointConfiguration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the robot current configuration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseConfiguration</td><td>transformation identifying the base pose with respect to the world frame </td></tr>
    <tr><td class="paramname">robotConfiguration</td><td>the robot configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the size (and order) of jointConfiguration must match the joints in the model, not in the consideredJoints variable</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a321cd9fba3a93857acbf81ee7ce89d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321cd9fba3a93857acbf81ee7ce89d6f">&#9670;&nbsp;</a></span>setJointConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setJointConfiguration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jointName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>jointConfiguration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set configuration for the specified joint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jointName</td><td>name of the joint </td></tr>
    <tr><td class="paramname">jointConfiguration</td><td>new value for the joint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a1f3be372eb31516aeb39e3e0a6ae8724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3be372eb31516aeb39e3e0a6ae8724">&#9670;&nbsp;</a></span>setRotationParametrization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setRotationParametrization </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="namespaceiDynTree.html#a04da5add9479687cf4c7eb873e717c6c">InverseKinematicsRotationParametrization</a>&#160;</td>
          <td class="paramname"><em>parametrization</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16f3902ff47fbafeb219c2e22529857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f3902ff47fbafeb219c2e22529857d">&#9670;&nbsp;</a></span>rotationParametrization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiDynTree.html#a04da5add9479687cf4c7eb873e717c6c">InverseKinematicsRotationParametrization</a> iDynTree::InverseKinematics::rotationParametrization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd8b70a018553ec30f0998092ea28c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8b70a018553ec30f0998092ea28c62">&#9670;&nbsp;</a></span>setMaxIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setMaxIterations </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Maximum Iteration. </p>
<p>The default value for this parameter is 3000 .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_iter</td><td>exits if iter&gt;=max_iter (max_iter&lt;0 disables this check). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e1534f0883aa48bbd7396fb03ab9cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1534f0883aa48bbd7396fb03ab9cc3">&#9670;&nbsp;</a></span>maxIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iDynTree::InverseKinematics::maxIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current value of Maximum Iteration. </p>
<dl class="section return"><dt>Returns</dt><dd>max_iter. </dd></dl>

</div>
</div>
<a id="a94fbd05f09b0fa2d7f98af110992dd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fbd05f09b0fa2d7f98af110992dd02">&#9670;&nbsp;</a></span>setMaxCPUTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setMaxCPUTime </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_cpu_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Maximum CPU seconds. </p>
<p>The default value for this parameter is $ 10^{6} $ .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_cpu_time</td><td>exits if cpu_time&gt;=max_cpu_time given in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7022f8652423611388707ad40ca71205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022f8652423611388707ad40ca71205">&#9670;&nbsp;</a></span>maxCPUTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iDynTree::InverseKinematics::maxCPUTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current value of Maximum CPU seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>max_cpu_time. </dd></dl>

</div>
</div>
<a id="a972eaa443d246d15a411b8b0c5e70a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972eaa443d246d15a411b8b0c5e70a62">&#9670;&nbsp;</a></span>setCostTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setCostTolerance </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets cost function tolerance. </p>
<p>The default value for this parameter is $ 10^{-8} $ .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td>tolerance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a902ce28213d60568f68456511f57493e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902ce28213d60568f68456511f57493e">&#9670;&nbsp;</a></span>costTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iDynTree::InverseKinematics::costTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves cost function tolerance. </p>
<dl class="section return"><dt>Returns</dt><dd>tolerance. </dd></dl>

</div>
</div>
<a id="a963881a6913d92c4a224b68af44918fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963881a6913d92c4a224b68af44918fb">&#9670;&nbsp;</a></span>setConstraintsTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setConstraintsTolerance </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>constr_tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets constraints tolerance. </p>
<p>The default value for this parameter is $ 10^{-4} $ .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td>tolerance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a431451fac26b849ab7b9157170926461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431451fac26b849ab7b9157170926461">&#9670;&nbsp;</a></span>constraintsTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iDynTree::InverseKinematics::constraintsTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves constraints tolerance. </p>
<dl class="section return"><dt>Returns</dt><dd>tolerance. </dd></dl>

</div>
</div>
<a id="a7fd58eaeec333ffe4a8b1cf68f48199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd58eaeec333ffe4a8b1cf68f48199a">&#9670;&nbsp;</a></span>setVerbosity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setVerbosity </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets Verbosity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>is a integer number which progressively enables different levels of warning messages or status dump. The larger this value the more detailed is the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79c65c3b6ecb3b1de2cf84b319dbcca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c65c3b6ecb3b1de2cf84b319dbcca0">&#9670;&nbsp;</a></span>linearSolverName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string iDynTree::InverseKinematics::linearSolverName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af45198b610d4f871a7fd0ed8b5b66846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45198b610d4f871a7fd0ed8b5b66846">&#9670;&nbsp;</a></span>setLinearSolverName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setLinearSolverName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solverName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e721cd49fb9d2910dab79677a3febc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e721cd49fb9d2910dab79677a3febc0">&#9670;&nbsp;</a></span>addFrameConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addFrameConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a (constancy) constraint for the specified frame</p>
<p>The constraint is \( {}^w_X_{frame}(q) = {}^w_X_{frame}(q^0) \) where the robot configuration \(q\) is the one specified with setRobotConfiguration </p><dl class="section note"><dt>Note</dt><dd>you should specify first the robot configuration. Otherwise call the versions with explicit constraint value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the frame name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ad32732917055324e9e43b665f10d6d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32732917055324e9e43b665f10d6d89">&#9670;&nbsp;</a></span>addFrameConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addFrameConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>constraintValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a (constancy) constraint for the specified frame</p>
<p>The homogeneous trasformation of the specified frame w.r.t. the inertial frame will remain constant and equal to the specified second parameter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the frame on which to attach the constraint </td></tr>
    <tr><td class="paramname">constraintValue</td><td>the transform to associate to the constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a8247e588e7c6a6caf37a52345c58a2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8247e588e7c6a6caf37a52345c58a2a3">&#9670;&nbsp;</a></span>addFramePositionConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addFramePositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;&#160;</td>
          <td class="paramname"><em>constraintValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a (constancy) position constraint for the specified frame</p>
<p>Only the position component of the frame is constrained </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the frame on which to attach the constraint </td></tr>
    <tr><td class="paramname">constraintValue</td><td>the position associated to the constraint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a08094142e67312af1c8dc6d43fcc5c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08094142e67312af1c8dc6d43fcc5c54">&#9670;&nbsp;</a></span>addFramePositionConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addFramePositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>constraintValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a (constancy) position constraint for the specified frame</p>
<p>Only the position component of the frame is constrained </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the frame on which to attach the constraint </td></tr>
    <tr><td class="paramname">constraintValue</td><td>the position associated to the constraint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a2581274da87dbf2b9cf8a8d1c34184fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2581274da87dbf2b9cf8a8d1c34184fb">&#9670;&nbsp;</a></span>addFrameRotationConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addFrameRotationConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>constraintValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a (constancy) orientation constraint for the specified frame</p>
<p>Only the orientation component of the frame is constrained </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the frame on which to attach the constraint </td></tr>
    <tr><td class="paramname">constraintValue</td><td>the orientation associated to the constraint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a053a41c48598e472cfc5acb69a707810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053a41c48598e472cfc5acb69a707810">&#9670;&nbsp;</a></span>addFrameRotationConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addFrameRotationConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>constraintValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a (constancy) orientation constraint for the specified frame</p>
<p>Only the orientation component of the frame is constrained </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the frame on which to attach the constraint </td></tr>
    <tr><td class="paramname">constraintValue</td><td>the orientation associated to the constraint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a2e2da211d3d7091ad07a0b384b3ff48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2da211d3d7091ad07a0b384b3ff48d">&#9670;&nbsp;</a></span>activateFrameConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::activateFrameConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>newConstraintValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activate a given constraint previously added with an addFrame**Constraint method.</p>
<dl class="section note"><dt>Note</dt><dd>In this version of <a class="el" href="namespaceiDynTree.html">iDynTree</a>, it is not possible to change the nature of the constraint (Full, <a class="el" href="classiDynTree_1_1Position.html" title="Class representation the coordinates of the Position of a point with respect to another point...">Position</a> or <a class="el" href="classiDynTree_1_1Rotation.html" title="Class representation the rotation of an orientation frame with respect to a reference orientation fra...">Rotation</a>) when activating it again.</dd>
<dd>
This method returns true even if the frame constraint was already activate, it only returns false if the constraint was never added. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is not meant to be called at each IK loop, and it can increase the computational time of the next call to solve.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the frame on which to attach the constraint </td></tr>
    <tr><td class="paramname">newConstraintValue</td><td>the pose of the constrained frame (r) in the world frame (w), i.e. ʷHᵣ . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a71611b4b312177be7c3682164742304a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71611b4b312177be7c3682164742304a">&#9670;&nbsp;</a></span>deactivateFrameConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::deactivateFrameConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deactivate a given constraint previously added with an addFrame**Constraint method.</p>
<dl class="section note"><dt>Note</dt><dd>This method returns true even if the frame constraint was already deactivated, it only returns false if the constraint was never added.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the frame on which to attach the constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful (i.e. the constraint is present) , false otherwise. </dd></dl>

</div>
</div>
<a id="a762635dbe437ce96d4e5e597267be87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762635dbe437ce96d4e5e597267be87d">&#9670;&nbsp;</a></span>isFrameConstraintActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::isFrameConstraintActive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given constraint is active or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameName</td><td>the name of the constrained frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the constraint is active, false if it is not active or it does not exist, or if the frame does not exist. </dd></dl>

</div>
</div>
<a id="af42335e61bf9fcb4fb62a7d48904e517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42335e61bf9fcb4fb62a7d48904e517">&#9670;&nbsp;</a></span>addCenterOfMassProjectionConstraint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addCenterOfMassProjectionConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>firstSupportFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>firstSupportPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a>&#160;</td>
          <td class="paramname"><em>xAxisOfPlaneInWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a>&#160;</td>
          <td class="paramname"><em>yAxisOfPlaneInWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a>&#160;</td>
          <td class="paramname"><em>originOfPlaneInWorld</em> = <code><a class="el" href="classiDynTree_1_1Position.html#aee87490c47a300dd487d35bef3ce4a1e">iDynTree::Position::Zero</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization of addCenterOfMassProjectionConstraint when only two support frames are specified. </p>

</div>
</div>
<a id="a9bdeb6bdba32b5b98f8942bd73bdf70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdeb6bdba32b5b98f8942bd73bdf70c">&#9670;&nbsp;</a></span>addCenterOfMassProjectionConstraint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addCenterOfMassProjectionConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>firstSupportFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>firstSupportPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>secondSupportFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>secondSupportPolygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a>&#160;</td>
          <td class="paramname"><em>xAxisOfPlaneInWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a>&#160;</td>
          <td class="paramname"><em>yAxisOfPlaneInWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a>&#160;</td>
          <td class="paramname"><em>originOfPlaneInWorld</em> = <code><a class="el" href="classiDynTree_1_1Position.html#aee87490c47a300dd487d35bef3ce4a1e">iDynTree::Position::Zero</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization of addCenterOfMassProjectionConstraint when only two support frames are specified. </p>

</div>
</div>
<a id="a5b7509e262a0293039b0ca99daf6344d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7509e262a0293039b0ca99daf6344d">&#9670;&nbsp;</a></span>addCenterOfMassProjectionConstraint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addCenterOfMassProjectionConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>supportFrames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classiDynTree_1_1Polygon.html">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>supportPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a>&#160;</td>
          <td class="paramname"><em>xAxisOfPlaneInWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Direction.html">iDynTree::Direction</a>&#160;</td>
          <td class="paramname"><em>yAxisOfPlaneInWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a>&#160;</td>
          <td class="paramname"><em>originOfPlaneInWorld</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a constant inequality constraint on the projection of the center of mass, assuming an arbitrary number of support links.</p>
<p>If a subset of the supportFrames is contrained by a FrameConstraint (both position and constraint) and such constraint is active, this constraint adds a inequality constraint to ensure that the center of mass projection lies on the convex hull of the contact polygons. </p>

</div>
</div>
<a id="ab430e2a8abbea4b7b02fc7535109ad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab430e2a8abbea4b7b02fc7535109ad9f">&#9670;&nbsp;</a></span>getCenterOfMassProjectionMargin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double iDynTree::InverseKinematics::getCenterOfMassProjectionMargin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the distance between the projection of the center of mass projection for the current configuration (set through setRobotConfiguration) and the limit of the convex hull (positive if the center of mass is inside the convex hull, negative if the com is outside the convex hull).</p>
<p>If no constraint has been added through a call to addCenterOfMassProjectionConstraint, return 0.0 .</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Move this function in a contraint-specific class. </dd></dl>

</div>
</div>
<a id="a30e3692826f3c14bc9d0948285451bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e3692826f3c14bc9d0948285451bfa">&#9670;&nbsp;</a></span>getCenterOfMassProjectConstraintConvexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::getCenterOfMassProjectConstraintConvexHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1Polygon2D.html">Polygon2D</a> &amp;&#160;</td>
          <td class="paramname"><em>convexHull</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active convex hull. </p>
<p>The convex hull returned is expressed in the plane defined by the xAxisOfPlaneInWorld, yAxisOfPlaneInWorld and originOfPlaneInWorld arguments of the addCenterOfMassProjectionConstraint methods.</p>
<p>The transform world_H_constraintFrame that describe how the support polygon for each support frame is transformed in the world frame are the one set in the addFrameConstraint method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">convexHull</td><td>constraint convex hull for the projected center of mass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the center of mass projection constraint is active, false otherwise. </dd></dl>

</div>
</div>
<a id="af97c2d5f44b64f7e422e70d20c0d49c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97c2d5f44b64f7e422e70d20c0d49c9">&#9670;&nbsp;</a></span>addTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>positionWeight</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rotationWeight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a target for the specified frame</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the frame should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positionWeight</td><td>if the position part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is 1.0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotationWeight</td><td>if the rotation part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is 1.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a9f9571f744198e189b3635cf18b01fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9571f744198e189b3635cf18b01fa6">&#9670;&nbsp;</a></span>addPositionTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addPositionTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>positionWeight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a position (3D) target for the specified frame</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the origin of the frame frameName should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positionWeight</td><td>if the position part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is 1.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a43517efef7345effef2c64ed792293d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43517efef7345effef2c64ed792293d6">&#9670;&nbsp;</a></span>addPositionTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addPositionTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>positionWeight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a position (3D) target for the specified frame</p>
<dl class="section note"><dt>Note</dt><dd>only the position component of the targetValue parameter will be considered </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the origin of the frame frameName should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positionWeight</td><td>if the position part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is 1.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="aed8c88ba1c622755f8f6060d7c23f1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8c88ba1c622755f8f6060d7c23f1b0">&#9670;&nbsp;</a></span>addRotationTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addRotationTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rotationWeight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an orientation target for the specified frame</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the orientation of the frame frameName should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotationWeight</td><td>if the rotation part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is 1.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="aef054698a036960b0cd9c4201553adee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef054698a036960b0cd9c4201553adee">&#9670;&nbsp;</a></span>addRotationTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::addRotationTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rotationWeight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an orientation target for the specified frame</p>
<dl class="section note"><dt>Note</dt><dd>only the orientation component of the targetValue parameter will be considered</dd></dl>
<p>This call is equivalent to call </p><div class="fragment"><div class="line"><a class="code" href="classiDynTree_1_1InverseKinematics.html#aed8c88ba1c622755f8f6060d7c23f1b0">addRotationTarget</a>(frameName, targetValue.rotation());</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>addRotationTarget(const std::string&amp;, const iDynTree::Rotation&amp;) addTarget(const std::string&amp;, const iDynTree::Transform&amp;)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the orientation of the frame frameName should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotationWeight</td><td>if the rotation part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is 1.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="afc04477ad6b4db5fe0ed87eaec33a366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc04477ad6b4db5fe0ed87eaec33a366">&#9670;&nbsp;</a></span>updateTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::updateTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>positionWeight</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rotationWeight</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the desired target and weights for the specified frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the frame should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positionWeight</td><td>if the position part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is the the last one previously set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotationWeight</td><td>if the rotation part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is the the last one previously set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise, for example if the specified frame target was not previously added with addTarget . </dd></dl>

</div>
</div>
<a id="a242d903b37077336e8a7401390968e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242d903b37077336e8a7401390968e6c">&#9670;&nbsp;</a></span>updatePositionTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::updatePositionTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>positionWeight</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the position (3D) target for the specified frame</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the origin of the frame frameName should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positionWeight</td><td>if the position part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is the last one previously set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise, for example if the specified frame target was not previously added with addTarget or addPositionTarget . </dd></dl>

</div>
</div>
<a id="a39d99a353d47eae1b831969affc69a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d99a353d47eae1b831969affc69a38">&#9670;&nbsp;</a></span>updateRotationTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::updateRotationTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Rotation.html">iDynTree::Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rotationWeight</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update an orientation target for the specified frame</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frameName</td><td>the name of the frame which represents the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">targetValue</td><td>value that the orientation of the frame frameName should reach </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotationWeight</td><td>if the rotation part of the target is handled as a term in the cost function, this specify the weight of this term in the cost function. Default value is the last one previously set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise, for example if the specified frame target was not previously added with addTarget or addRotationTarget . </dd></dl>

</div>
</div>
<a id="ac55e7751070535950a098125d6064d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55e7751070535950a098125d6064d46">&#9670;&nbsp;</a></span>setDefaultTargetResolutionMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setDefaultTargetResolutionMode </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">iDynTree::InverseKinematicsTreatTargetAsConstraint</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify the default method to solve all the specified targets</p>
<p>Targets can be solved fully as cost, partially (position or orientation) as cost and the other component as hard constraint or fully as hard constraints </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classiDynTree_1_1InverseKinematics.html#ae5dff5d4891a60e0aeb2c8c66c25c43a">targetResolutionMode()</a> All the newly added target will have as default resolution mode the one specified in this function. Existing targets will remain unchanged</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the target resolution mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ada2c44f94a48893d064e90c3400e593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2c44f94a48893d064e90c3400e593d">&#9670;&nbsp;</a></span>defaultTargetResolutionMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">iDynTree::InverseKinematicsTreatTargetAsConstraint</a> iDynTree::InverseKinematics::defaultTargetResolutionMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the default method to solve all the specified targets</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classiDynTree_1_1InverseKinematics.html#ac55e7751070535950a098125d6064d46">setDefaultTargetResolutionMode()</a> All the newly added target will have as default resolution mode the one returned in this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current default method to solve targets </dd></dl>

</div>
</div>
<a id="a40c0473418948bdaeb1b002ff167e550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c0473418948bdaeb1b002ff167e550">&#9670;&nbsp;</a></span>setTargetResolutionMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setTargetResolutionMode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>targetName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">InverseKinematicsTreatTargetAsConstraint</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify the method to solve the specified target</p>
<p>Targets can be solved fully as cost, partially (position or orientation) as cost and the other component as hard constraint or fully as hard constraints </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classiDynTree_1_1InverseKinematics.html#ae5dff5d4891a60e0aeb2c8c66c25c43a">targetResolutionMode()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the target resolution mode </td></tr>
    <tr><td class="paramname">targetName</td><td>the name (frame) identified the target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise, for example if the specified frame target was not previously added with addTarget or addRotationTarget . </dd></dl>

</div>
</div>
<a id="ae5dff5d4891a60e0aeb2c8c66c25c43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5dff5d4891a60e0aeb2c8c66c25c43a">&#9670;&nbsp;</a></span>targetResolutionMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiDynTree.html#a5cb905194c9ee61c0a23b32d603b2df2">InverseKinematicsTreatTargetAsConstraint</a> iDynTree::InverseKinematics::targetResolutionMode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the target resolution mode</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classiDynTree_1_1InverseKinematics.html#a40c0473418948bdaeb1b002ff167e550">setTargetResolutionMode</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the target hasn't been specified yet, it returns "InverseKinematicsTreatTargetAsConstraintNone" </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current target resolution mode, or InverseKinematicsTreatTargetAsConstraintNone if the target cannot be found </dd></dl>

</div>
</div>
<a id="aff9003fa17de9f6467b127bc2809dd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9003fa17de9f6467b127bc2809dd10">&#9670;&nbsp;</a></span>setDesiredJointConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setDesiredJointConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>desiredJointConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a desired final configuration for the joints.</p>
<p>The solver will try to obtain solutions as similar to the specified configuration as possible</p>
<dl class="section note"><dt>Note</dt><dd>the desiredJointConfiguration have the same serialisation of the joints in the specified model</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredJointConfiguration</td><td>configuration for the joints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>weight for the joint configuration cost. If it is not passed, the previous passed value will be mantained. If the value was never passed, its value is 1e-6 .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a30597bf9cef5da3d0c30118a1c132a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30597bf9cef5da3d0c30118a1c132a2c">&#9670;&nbsp;</a></span>setDesiredFullJointsConfiguration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setDesiredFullJointsConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>desiredJointConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a desired final configuration for all the robot joints.</p>
<p>The solver will try to obtain solutions as similar to the specified configuration as possible</p>
<dl class="section note"><dt>Note</dt><dd>the desiredJointConfiguration have the same serialisation of the joints in the specified model</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredJointConfiguration</td><td>configuration for the joints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>weight for the joint configuration cost. If it is not passed, the previous passed value will be mantained. If the value was never passed, its value is 1e-6 .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a50c9eede82cbe551388baceed52240ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c9eede82cbe551388baceed52240ee">&#9670;&nbsp;</a></span>setDesiredFullJointsConfiguration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setDesiredFullJointsConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>desiredJointConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a desired final configuration for all the robot joints.</p>
<p>The solver will try to obtain solutions as similar to the specified configuration as possible</p>
<dl class="section note"><dt>Note</dt><dd>the desiredJointConfiguration have the same serialisation of the joints in the specified model</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredJointConfiguration</td><td>configuration for the joints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Joint-wise weights for the joint configuration cost. This vector should have the same dimension of the desiredJointConfiguration. If one of its elements is negative, the previous value will be kept. If the value was never passed, its value is 1e-6, equal for all joints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="af22154b11fa87fbb0be902f85e4a4a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22154b11fa87fbb0be902f85e4a4a37">&#9670;&nbsp;</a></span>setDesiredReducedJointConfiguration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setDesiredReducedJointConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>desiredJointConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a desired final configuration for the set of considered joints.</p>
<p>The solver will try to obtain solutions as similar to the specified configuration as possible</p>
<dl class="section note"><dt>Note</dt><dd>the desiredJointConfiguration have the same order of the joints in the consideredJoints list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredJointConfiguration</td><td>configuration for the joints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>weight for the joint configuration cost. If it is not passed, the previous passed value will be mantained. If the value was never passed, its value is 1e-6 .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ae084dff57455232ec11cfe81f9888eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae084dff57455232ec11cfe81f9888eda">&#9670;&nbsp;</a></span>setDesiredReducedJointConfiguration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setDesiredReducedJointConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>desiredJointConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a desired final configuration for the set of considered joints.</p>
<p>The solver will try to obtain solutions as similar to the specified configuration as possible</p>
<dl class="section note"><dt>Note</dt><dd>the desiredJointConfiguration have the same order of the joints in the consideredJoints list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredJointConfiguration</td><td>configuration for the joints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Joint-wise weights for the joint configuration cost. This vector should have the same dimension of the desiredJointConfiguration. If one of its elements is negative, the previous value will be kept. If the value was never passed, its value is 1e-6, equal for all joints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a4e61084a8305a1d089add9bff5a632ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e61084a8305a1d089add9bff5a632ea">&#9670;&nbsp;</a></span>setInitialCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setInitialCondition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> *&#160;</td>
          <td class="paramname"><em>baseTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> *&#160;</td>
          <td class="paramname"><em>initialCondition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initial guess for the solution</p>
<dl class="section note"><dt>Note</dt><dd>the initialCondition variable have the same serialisation of the joints in the specified model </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseTransform</td><td>initial base pose </td></tr>
    <tr><td class="paramname">initialCondition</td><td>initial joints configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a79edd849ba6eb8d0b549cad3c9c00106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79edd849ba6eb8d0b549cad3c9c00106">&#9670;&nbsp;</a></span>setFullJointsInitialCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setFullJointsInitialCondition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> *&#160;</td>
          <td class="paramname"><em>baseTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> *&#160;</td>
          <td class="paramname"><em>initialCondition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af16eec79ccbccf5a180d46e874712e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16eec79ccbccf5a180d46e874712e53">&#9670;&nbsp;</a></span>setReducedInitialCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::setReducedInitialCondition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> *&#160;</td>
          <td class="paramname"><em>baseTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> *&#160;</td>
          <td class="paramname"><em>initialCondition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4d51059431c6fed8e83983379e143d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d51059431c6fed8e83983379e143d3">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5251d7fd8b862b7b69278bbaf41e5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5251d7fd8b862b7b69278bbaf41e5b8">&#9670;&nbsp;</a></span>getSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::getSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>baseTransformSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>shapeSolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last solution of the inverse kinematics problem</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseTransformSolution</td><td>solution for the base position </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shapeSolution</td><td>solution for the shape (the internal configurations) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82b937b35239f7b262391961f4c448ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b937b35239f7b262391961f4c448ea">&#9670;&nbsp;</a></span>getFullJointsSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::getFullJointsSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>baseTransformSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>shapeSolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fe2c9cd84677f6dfd83fdc31e6e39e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe2c9cd84677f6dfd83fdc31e6e39e6">&#9670;&nbsp;</a></span>getReducedSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::getReducedSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>baseTransformSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>shapeSolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last solution of the inverse kinematics problem</p>
<p>This method returns in the shapeSolution variable only the joints that have been optimised viz. only the joints specified in the consideredJoints variable in the initialization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseTransformSolution</td><td>solution for the base position </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shapeSolution</td><td>solution for the shape (the internal configurations) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af672ccd4e2c30ac0ebbff58146ded4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af672ccd4e2c30ac0ebbff58146ded4a9">&#9670;&nbsp;</a></span>getPoseForFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::getPoseForFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frameName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1Transform.html">iDynTree::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dce3f3bfd9f50334386ba1470c3f53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dce3f3bfd9f50334386ba1470c3f53f">&#9670;&nbsp;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classiDynTree_1_1Model.html">Model</a> &amp; iDynTree::InverseKinematics::model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the model used by the <a class="el" href="classiDynTree_1_1InverseKinematics.html" title="NLP-based Inverse kinematics. ">InverseKinematics</a> .</p>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to <a class="el" href="classiDynTree_1_1Model.html" title="Class that represents a generic multibody model. ">iDynTree::Model</a> used by the inverse kinematics. </dd></dl>

</div>
</div>
<a id="a1a6ef09da0cb4ddb68261529a45f3f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6ef09da0cb4ddb68261529a45f3f2f">&#9670;&nbsp;</a></span>fullModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classiDynTree_1_1Model.html">Model</a> &amp; iDynTree::InverseKinematics::fullModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a880e07ce1aea19321ecdaaaa8dcb0a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880e07ce1aea19321ecdaaaa8dcb0a84">&#9670;&nbsp;</a></span>reducedModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classiDynTree_1_1Model.html">Model</a> &amp; iDynTree::InverseKinematics::reducedModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a176c4c0e2471a8af391e7b156b04a2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176c4c0e2471a8af391e7b156b04a2b0">&#9670;&nbsp;</a></span>setCOMTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setCOMTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1Position.html">iDynTree::Position</a> &amp;&#160;</td>
          <td class="paramname"><em>desiredPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a557041738a620f4ce2ef433083b9b3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557041738a620f4ce2ef433083b9b3a0">&#9670;&nbsp;</a></span>setCOMAsConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setCOMAsConstraint </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asConstraint</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2776f60ee744d261552c5685bec170f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2776f60ee744d261552c5685bec170f">&#9670;&nbsp;</a></span>setCOMAsConstraintTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setCOMAsConstraintTolerance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-8</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc2d97dd6ed312e557fbee2a5d91e313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2d97dd6ed312e557fbee2a5d91e313">&#9670;&nbsp;</a></span>isCOMAConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::isCOMAConstraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20284b4e939d67add4a1a90bba06dc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20284b4e939d67add4a1a90bba06dc0c">&#9670;&nbsp;</a></span>isCOMTargetActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::InverseKinematics::isCOMTargetActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae834df2d99d5332143bb3ab617ea54e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae834df2d99d5332143bb3ab617ea54e7">&#9670;&nbsp;</a></span>deactivateCOMTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::deactivateCOMTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a77ce138803d1db8f2db9f1927034de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a77ce138803d1db8f2db9f1927034de">&#9670;&nbsp;</a></span>setCOMConstraintProjectionDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::InverseKinematics::setCOMConstraintProjectionDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiDynTree.html#a6ba91315448cf1d275f460097e36d134">iDynTree::Vector3</a>&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the directions along which a point will be projected.</p>
<dl class="section author"><dt>Author</dt><dd>Aiko Dinale (29/08/2017)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>vector along which we want to project a point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="InverseKinematics_8h.html">InverseKinematics.h</a></li>
<li><a class="el" href="InverseKinematics_8cpp.html">InverseKinematics.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiDynTree.html">iDynTree</a></li><li class="navelem"><a class="el" href="classiDynTree_1_1InverseKinematics.html">InverseKinematics</a></li>
    <li class="footer">Generated on Fri Jan 10 2020 08:54:56 for iDynTree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
