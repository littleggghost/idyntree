<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iDynTree: iDynTree::DiscreteExtendedKalmanFilterHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iDynTree
   </div>
   <div id="projectbrief">Free floating robots dynamics library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iDynTree::DiscreteExtendedKalmanFilterHelper Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>class implementation of discrete EKF with additive Gaussian noise  
 <a href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#details">More...</a></p>

<p><code>#include &lt;ExtendedKalmanFilter.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for iDynTree::DiscreteExtendedKalmanFilterHelper:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper__inherit__graph.svg" width="246" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cb21a197ab80253529694710473c0fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a6cb21a197ab80253529694710473c0fd">DiscreteExtendedKalmanFilterHelper</a> ()</td></tr>
<tr class="separator:a6cb21a197ab80253529694710473c0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35db724dab6168cb3d84e44cbb809ea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#aa35db724dab6168cb3d84e44cbb809ea">ekf_f</a> (const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;x_k, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;u_k, <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;xhat_k_plus_one)=0</td></tr>
<tr class="memdesc:aa35db724dab6168cb3d84e44cbb809ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the state propagation for a given dynamical system If state of the system is denoted by \( x \) and the control input by \( u \), then the system dynamics is given as \( x_{k+1} = f(x_k, u_k) \).  <a href="#aa35db724dab6168cb3d84e44cbb809ea">More...</a><br /></td></tr>
<tr class="separator:aa35db724dab6168cb3d84e44cbb809ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823fd6ec74999d302d6ba38322de1a82"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a823fd6ec74999d302d6ba38322de1a82">ekf_h</a> (const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;xhat_k_plus_one, <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;zhat_k_plus_one)=0</td></tr>
<tr class="memdesc:a823fd6ec74999d302d6ba38322de1a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the measurement model of the system, i.e., how the measurements can be described as a function of states, Given a state of the system described by \( x \), what would be the measurement \( z \) observed from this state \( z_{k+1} = h(\hat{x}_{k+1}) \).  <a href="#a823fd6ec74999d302d6ba38322de1a82">More...</a><br /></td></tr>
<tr class="separator:a823fd6ec74999d302d6ba38322de1a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe816c4328411dcdd86426b1877510f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#acfe816c4328411dcdd86426b1877510f">ekfComputeJacobianF</a> (<a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;x, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">iDynTree::MatrixDynSize</a> &amp;F)=0</td></tr>
<tr class="memdesc:acfe816c4328411dcdd86426b1877510f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#acfe816c4328411dcdd86426b1877510f">More...</a><br /></td></tr>
<tr class="separator:acfe816c4328411dcdd86426b1877510f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f048b7cf4b255e9d77b06edf7d4f3d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#aa5f048b7cf4b255e9d77b06edf7d4f3d">ekfComputeJacobianF</a> (<a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;x, <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;u, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">iDynTree::MatrixDynSize</a> &amp;F)=0</td></tr>
<tr class="memdesc:aa5f048b7cf4b255e9d77b06edf7d4f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the system Jacobian necessary for the propagation of predicted state covariance The analytical Jacobian describing the partial derivative of the system propagation with respect to the state and the system propagation with respect to the input.  <a href="#aa5f048b7cf4b255e9d77b06edf7d4f3d">More...</a><br /></td></tr>
<tr class="separator:aa5f048b7cf4b255e9d77b06edf7d4f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8729efeddce087e809db28749fb2da20"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a8729efeddce087e809db28749fb2da20">ekfComputeJacobianH</a> (<a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;x, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">iDynTree::MatrixDynSize</a> &amp;H)=0</td></tr>
<tr class="memdesc:a8729efeddce087e809db28749fb2da20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the measurement Jacobian necessary for computing Kalman gain and updating the predicted state and its covariance The analytical Jacobian describing the partial derivative of the measurement model with respect to the state.  <a href="#a8729efeddce087e809db28749fb2da20">More...</a><br /></td></tr>
<tr class="separator:a8729efeddce087e809db28749fb2da20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e0c6ab212f148079af396e0eb69244"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244">ekfPredict</a> ()</td></tr>
<tr class="memdesc:a06e0c6ab212f148079af396e0eb69244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Discrete EKF prediction equation described by \( \hat{x}_{k+1} = f(x_k, u_k) \) is given by the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#aa35db724dab6168cb3d84e44cbb809ea" title="Describes the state propagation for a given dynamical system If state of the system is denoted by  an...">ekf_f()</a> method \( \hat{P}_{k+1} = F_k P_k F_k^T + Q \) where, \( F \mid_{x = x_k} \) is given by the ekfComputejacobianF() method.  <a href="#a06e0c6ab212f148079af396e0eb69244">More...</a><br /></td></tr>
<tr class="separator:a06e0c6ab212f148079af396e0eb69244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3511ef7000edb1af2f22c750ac5ccb63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63">ekfUpdate</a> ()</td></tr>
<tr class="memdesc:a3511ef7000edb1af2f22c750ac5ccb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Discrete EKF update equation described by \( z_{k+1} = h(\hat{x}_{k+1}) \) is given by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a823fd6ec74999d302d6ba38322de1a82" title="Describes the measurement model of the system, i.e., how the measurements can be described as a funct...">ekf_h()</a> method innovation \( \tilde{y}_{k+1} = y_{k+1} - z_{k+1} \) innovation covariance \( S_{k+1} = H_{k+1} \hat{P}_{k+1} H_{k+1}^T + R \), where \( H \mid_{x = \hat{x}_{k+1}} \) is given by ekfComputejacobianH() method Kalman gain \( K_{k+1} = \hat{P}_{k+1} H_{k+1}^T S_{k+1}^{-1} \) Updated covariance \( P_{k+1} = \hat{P}_{k+1} - (K_{k+1} H \hat{P}_{k+1}) \) Updated state estimate \( x_{k+1} = \hat{x}_{k+1} + K_{k+1} \tilde{y}_{k+1} \).  <a href="#a3511ef7000edb1af2f22c750ac5ccb63">More...</a><br /></td></tr>
<tr class="separator:a3511ef7000edb1af2f22c750ac5ccb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37450d1833a7ce6d7b2caec4e00c9a62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62">ekfInit</a> ()</td></tr>
<tr class="memdesc:a37450d1833a7ce6d7b2caec4e00c9a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and resizes the internal buffers of this filter.  <a href="#a37450d1833a7ce6d7b2caec4e00c9a62">More...</a><br /></td></tr>
<tr class="separator:a37450d1833a7ce6d7b2caec4e00c9a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dda1a9c2249dc1d7d38dbc6da69b8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a48dda1a9c2249dc1d7d38dbc6da69b8b">ekfInit</a> (const size_t &amp;state_size, const size_t &amp;input_size, const size_t &amp;output_size)</td></tr>
<tr class="memdesc:a48dda1a9c2249dc1d7d38dbc6da69b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and resizes the internal buffers of this filter.  <a href="#a48dda1a9c2249dc1d7d38dbc6da69b8b">More...</a><br /></td></tr>
<tr class="separator:a48dda1a9c2249dc1d7d38dbc6da69b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236c419106fbe83a4651cdd8f28fb3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a236c419106fbe83a4651cdd8f28fb3f8">ekfReset</a> ()</td></tr>
<tr class="memdesc:a236c419106fbe83a4651cdd8f28fb3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the filter flags The filter flags check if the filter was properly initialized, if the initial state was set, if the initial state covariance was set.  <a href="#a236c419106fbe83a4651cdd8f28fb3f8">More...</a><br /></td></tr>
<tr class="separator:a236c419106fbe83a4651cdd8f28fb3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5980548288752504e9e4758b532e4c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a5980548288752504e9e4758b532e4c66">ekfReset</a> (const size_t &amp;state_size, const size_t &amp;input_size, const size_t &amp;output_size, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;x0, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;P0, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;Q, const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;R)</td></tr>
<tr class="memdesc:a5980548288752504e9e4758b532e4c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the filter flags, initializes and resizes internal buffers of the filter, and sets initial state, initial state covariance, and system noise and measurement noise covariance matrices.  <a href="#a5980548288752504e9e4758b532e4c66">More...</a><br /></td></tr>
<tr class="separator:a5980548288752504e9e4758b532e4c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395b24fd4ae30bb88b35179ea80117cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb">ekfSetMeasurementVector</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;y)</td></tr>
<tr class="memdesc:a395b24fd4ae30bb88b35179ea80117cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set measurement vector at every time step the measurement vector size and output size should match.  <a href="#a395b24fd4ae30bb88b35179ea80117cb">More...</a><br /></td></tr>
<tr class="separator:a395b24fd4ae30bb88b35179ea80117cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ec69c3ded347027f494c84af300d45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45">ekfSetInputVector</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;u)</td></tr>
<tr class="memdesc:af2ec69c3ded347027f494c84af300d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set input vector at every time step the input vector size and input size should match.  <a href="#af2ec69c3ded347027f494c84af300d45">More...</a><br /></td></tr>
<tr class="separator:af2ec69c3ded347027f494c84af300d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc0fd06681f866166e527abf303929e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#abcc0fd06681f866166e527abf303929e">ekfSetInitialState</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;x0)</td></tr>
<tr class="memdesc:abcc0fd06681f866166e527abf303929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial state the size of x0 and state size should match.  <a href="#abcc0fd06681f866166e527abf303929e">More...</a><br /></td></tr>
<tr class="separator:abcc0fd06681f866166e527abf303929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557ecd035b2ff1e2267d3f98c0cf3a35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a557ecd035b2ff1e2267d3f98c0cf3a35">ekfSetStateCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;P)</td></tr>
<tr class="memdesc:a557ecd035b2ff1e2267d3f98c0cf3a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial state covariance matrix the size of P and (state size*state size) should match.  <a href="#a557ecd035b2ff1e2267d3f98c0cf3a35">More...</a><br /></td></tr>
<tr class="separator:a557ecd035b2ff1e2267d3f98c0cf3a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927eee549a560c68d95cbea5b0cec797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a927eee549a560c68d95cbea5b0cec797">ekfSetSystemNoiseCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;Q)</td></tr>
<tr class="memdesc:a927eee549a560c68d95cbea5b0cec797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set system noise covariance matrix the size of Q and (state size*state size) should match.  <a href="#a927eee549a560c68d95cbea5b0cec797">More...</a><br /></td></tr>
<tr class="separator:a927eee549a560c68d95cbea5b0cec797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1bd4ba94586c78c477a4a3af1fce0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a0d1bd4ba94586c78c477a4a3af1fce0b">ekfSetMeasurementNoiseCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;R)</td></tr>
<tr class="memdesc:a0d1bd4ba94586c78c477a4a3af1fce0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set measurement noise covariance matrix the size of R and (output size*output size) should match.  <a href="#a0d1bd4ba94586c78c477a4a3af1fce0b">More...</a><br /></td></tr>
<tr class="separator:a0d1bd4ba94586c78c477a4a3af1fce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a4ba3b26206d2607d724866e4bfd1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a">ekfSetStateSize</a> (size_t dim_X)</td></tr>
<tr class="memdesc:a47a4ba3b26206d2607d724866e4bfd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state dimensions.  <a href="#a47a4ba3b26206d2607d724866e4bfd1a">More...</a><br /></td></tr>
<tr class="separator:a47a4ba3b26206d2607d724866e4bfd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301ab496750472b1681d509e30c75da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1">ekfSetInputSize</a> (size_t dim_U)</td></tr>
<tr class="memdesc:a301ab496750472b1681d509e30c75da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input dimensions.  <a href="#a301ab496750472b1681d509e30c75da1">More...</a><br /></td></tr>
<tr class="separator:a301ab496750472b1681d509e30c75da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e0003290ca166251c7d8bb4a80162d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d">ekfSetOutputSize</a> (size_t dim_Y)</td></tr>
<tr class="memdesc:af8e0003290ca166251c7d8bb4a80162d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ouptut dimensions.  <a href="#af8e0003290ca166251c7d8bb4a80162d">More...</a><br /></td></tr>
<tr class="separator:af8e0003290ca166251c7d8bb4a80162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b41687186a840fdd1b15288339c51e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a46b41687186a840fdd1b15288339c51e">ekfGetStates</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;x) const</td></tr>
<tr class="memdesc:a46b41687186a840fdd1b15288339c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current internal state of the filter the size of x and state size should match.  <a href="#a46b41687186a840fdd1b15288339c51e">More...</a><br /></td></tr>
<tr class="separator:a46b41687186a840fdd1b15288339c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac546a68e8ee705927c5dd9b57eb11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a65ac546a68e8ee705927c5dd9b57eb11">ekfGetStateCovariance</a> (const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;P) const</td></tr>
<tr class="memdesc:a65ac546a68e8ee705927c5dd9b57eb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get state covariance matrix the size of P and (state size*state size) should match.  <a href="#a65ac546a68e8ee705927c5dd9b57eb11">More...</a><br /></td></tr>
<tr class="separator:a65ac546a68e8ee705927c5dd9b57eb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a540be21bdc4ec8636da39190df3a3157"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a540be21bdc4ec8636da39190df3a3157"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a540be21bdc4ec8636da39190df3a3157">ignore</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:a540be21bdc4ec8636da39190df3a3157"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template to ignore unused parameters  <a href="#a540be21bdc4ec8636da39190df3a3157">More...</a><br /></td></tr>
<tr class="separator:a540be21bdc4ec8636da39190df3a3157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>class implementation of discrete EKF with additive Gaussian noise </p>
<dl class="section warning"><dt>Warning</dt><dd>This class is not stand-alone but can be used meaningfully only by classes deriving from it. The system propagation function f() and measurement model function h() are virtual functions to be defined by the derived class implementing the EKF. Similarly, the Jacobians for the linearized system propagation and measurement model are also virtual functions to be implemented by the derived class.</dd></dl>
<p>The derived class must must set the size for states, inputs and outputs using <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a" title="Set the state dimensions. ">ekfSetStateSize()</a>, <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1" title="Set the input dimensions. ">ekfSetInputSize()</a> and <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d" title="Set the ouptut dimensions. ">ekfSetOutputSize()</a> methods. Then the derived class must call <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> to resize the vectors and matrices for the EKF.</p>
<p>Similarly before running the estimator through a loop, it is recommended to set the initial states and variances for measurements, system dynamics and intial states. This is necessary to avoid any NaN values to be propagated.</p>
<p>Once, initialized properly, the filter can be run by</p><ul>
<li>calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45" title="Set input vector at every time step the input vector size and input size should match. ">ekfSetInputVector()</a> to set the control inputs and then calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244" title="Implements the Discrete EKF prediction equation described by  is given by the ekf_f() method  where...">ekfPredict()</a> at each prediction step, and</li>
<li>calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb" title="Set measurement vector at every time step the measurement vector size and output size should match...">ekfSetMeasurementVector()</a> to set the measurements and then calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63" title="Implements the Discrete EKF update equation described by  is given by ekf_h() method innovation  inno...">ekfUpdate()</a> at each update step</li>
</ul>
<p>The internal state of the estimator can be obtained by calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a46b41687186a840fdd1b15288339c51e" title="Get current internal state of the filter the size of x and state size should match. ">ekfGetStates()</a>.</p>
<p>The Discrete Extended Kalman Filter equations implemented in this class are coherent with the ones described in <a href="https://en.wikipedia.org/wiki/Extended_Kalman_filter">Discrete-time predict and update equations section of this article.</a></p>
<p>The general workflow implementing/inheriting this class would be in the order,</p><ul>
<li>call <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1" title="Set the input dimensions. ">ekfSetInputSize()</a>, <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d" title="Set the ouptut dimensions. ">ekfSetOutputSize()</a>, <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a" title="Set the state dimensions. ">ekfSetStateSize()</a> methods</li>
<li>call <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a></li>
<li>call <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#abcc0fd06681f866166e527abf303929e" title="Set initial state the size of x0 and state size should match. ">ekfSetInitialState()</a>, <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a557ecd035b2ff1e2267d3f98c0cf3a35" title="Set initial state covariance matrix the size of P and (state size*state size) should match...">ekfSetStateCovariance()</a> (either done externally later or internally. usually done externally later, however, filter runs properly only if this step is done)</li>
<li><p class="startli">call <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a927eee549a560c68d95cbea5b0cec797" title="Set system noise covariance matrix the size of Q and (state size*state size) should match...">ekfSetSystemNoiseCovariance()</a>, <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a0d1bd4ba94586c78c477a4a3af1fce0b" title="Set measurement noise covariance matrix the size of R and (output size*output size) should match...">ekfSetMeasurementNoiseCovariance()</a></p>
<p class="startli">once this is setup,</p>
</li>
<li>in a loop<ul>
<li>call <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45" title="Set input vector at every time step the input vector size and input size should match. ">ekfSetInputVector()</a> then <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244" title="Implements the Discrete EKF prediction equation described by  is given by the ekf_f() method  where...">ekfPredict()</a>. Calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a46b41687186a840fdd1b15288339c51e" title="Get current internal state of the filter the size of x and state size should match. ">ekfGetStates()</a> and <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a65ac546a68e8ee705927c5dd9b57eb11" title="Get state covariance matrix the size of P and (state size*state size) should match. ">ekfGetStateCovariance()</a> at this point will give us the predicted states and its covariance</li>
<li>call <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb" title="Set measurement vector at every time step the measurement vector size and output size should match...">ekfSetMeasurementVector()</a> then <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63" title="Implements the Discrete EKF update equation described by  is given by ekf_h() method innovation  inno...">ekfUpdate()</a>. Calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a46b41687186a840fdd1b15288339c51e" title="Get current internal state of the filter the size of x and state size should match. ">ekfGetStates()</a> and <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a65ac546a68e8ee705927c5dd9b57eb11" title="Get state covariance matrix the size of P and (state size*state size) should match. ">ekfGetStateCovariance()</a> at this point will give us the updated states and its covariance <dl class="section note"><dt>Note</dt><dd>if we intend to change the state size, input size or output size on the fly, it is crucial to call the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> method again, since this resizes the buffers accordingly failing to do so will result in memory leaks and will cause the program to crash. </dd></dl>
</li>
</ul>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6cb21a197ab80253529694710473c0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb21a197ab80253529694710473c0fd">&#9670;&nbsp;</a></span>DiscreteExtendedKalmanFilterHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynTree::DiscreteExtendedKalmanFilterHelper::DiscreteExtendedKalmanFilterHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa35db724dab6168cb3d84e44cbb809ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35db724dab6168cb3d84e44cbb809ea">&#9670;&nbsp;</a></span>ekf_f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekf_f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>x_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>u_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>xhat_k_plus_one</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the state propagation for a given dynamical system If state of the system is denoted by \( x \) and the control input by \( u \), then the system dynamics is given as \( x_{k+1} = f(x_k, u_k) \). </p>
<dl class="section note"><dt>Note</dt><dd>the detail of this function needs to be implemented by the child class </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_k</td><td>state at current time instant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u_k</td><td>control input at current time instant </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xhat_k_plus_one</td><td>predicted state without any correction from measurements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a823fd6ec74999d302d6ba38322de1a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823fd6ec74999d302d6ba38322de1a82">&#9670;&nbsp;</a></span>ekf_h()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekf_h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>xhat_k_plus_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>zhat_k_plus_one</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the measurement model of the system, i.e., how the measurements can be described as a function of states, Given a state of the system described by \( x \), what would be the measurement \( z \) observed from this state \( z_{k+1} = h(\hat{x}_{k+1}) \). </p>
<dl class="section note"><dt>Note</dt><dd>the detail of this function needs to be implemented by the child class </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xhat_k_plus_one</td><td>predicted state of next time instant </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">zhat_k_plus_one</td><td>predicted measurement of next time instant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="acfe816c4328411dcdd86426b1877510f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe816c4328411dcdd86426b1877510f">&#9670;&nbsp;</a></span>ekfComputeJacobianF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfComputeJacobianF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">iDynTree::MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa5f048b7cf4b255e9d77b06edf7d4f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f048b7cf4b255e9d77b06edf7d4f3d">&#9670;&nbsp;</a></span>ekfComputeJacobianF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfComputeJacobianF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">iDynTree::MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the system Jacobian necessary for the propagation of predicted state covariance The analytical Jacobian describing the partial derivative of the system propagation with respect to the state and the system propagation with respect to the input. </p>
<dl class="section note"><dt>Note</dt><dd>the detail of this function needs to be implemented by the child class </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>system state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>system input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>system Jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a8729efeddce087e809db28749fb2da20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8729efeddce087e809db28749fb2da20">&#9670;&nbsp;</a></span>ekfComputeJacobianH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfComputeJacobianH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">iDynTree::VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">iDynTree::MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the measurement Jacobian necessary for computing Kalman gain and updating the predicted state and its covariance The analytical Jacobian describing the partial derivative of the measurement model with respect to the state. </p>
<dl class="section note"><dt>Note</dt><dd>the detail of this function needs to be implemented by the child class </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>system state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td>measurement Jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a06e0c6ab212f148079af396e0eb69244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e0c6ab212f148079af396e0eb69244">&#9670;&nbsp;</a></span>ekfPredict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfPredict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the Discrete EKF prediction equation described by \( \hat{x}_{k+1} = f(x_k, u_k) \) is given by the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#aa35db724dab6168cb3d84e44cbb809ea" title="Describes the state propagation for a given dynamical system If state of the system is denoted by  an...">ekf_f()</a> method \( \hat{P}_{k+1} = F_k P_k F_k^T + Q \) where, \( F \mid_{x = x_k} \) is given by the ekfComputejacobianF() method. </p>
<dl class="section warning"><dt>Warning</dt><dd>this function can be called only after setting up the filter properly through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> step </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function should be once called every step, after setting up the input vector using <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45" title="Set input vector at every time step the input vector size and input size should match. ">ekfSetInputVector()</a> method </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>setting up the input vector everytime before calling the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244" title="Implements the Discrete EKF prediction equation described by  is given by the ekf_f() method  where...">ekfPredict()</a> method is crucial, the prediction step is not performed if this step is skipped this is because internally a flag associated to the setting up of input vector is set true by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af2ec69c3ded347027f494c84af300d45" title="Set input vector at every time step the input vector size and input size should match. ">ekfSetInputVector()</a> method which in turn is set false by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a06e0c6ab212f148079af396e0eb69244" title="Implements the Discrete EKF prediction equation described by  is given by the ekf_f() method  where...">ekfPredict()</a> method </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>
<p>&lt; \( \hat{x}_{k+1} = f(x_k, u_k) \)</p>
<p>&lt; \( F \mid_{x = x_k} \)</p>
<p>&lt; \( \hat{P}_{k+1} = F_k P_k F_k^T + Q \) </p>

</div>
</div>
<a id="a3511ef7000edb1af2f22c750ac5ccb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3511ef7000edb1af2f22c750ac5ccb63">&#9670;&nbsp;</a></span>ekfUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the Discrete EKF update equation described by \( z_{k+1} = h(\hat{x}_{k+1}) \) is given by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a823fd6ec74999d302d6ba38322de1a82" title="Describes the measurement model of the system, i.e., how the measurements can be described as a funct...">ekf_h()</a> method innovation \( \tilde{y}_{k+1} = y_{k+1} - z_{k+1} \) innovation covariance \( S_{k+1} = H_{k+1} \hat{P}_{k+1} H_{k+1}^T + R \), where \( H \mid_{x = \hat{x}_{k+1}} \) is given by ekfComputejacobianH() method Kalman gain \( K_{k+1} = \hat{P}_{k+1} H_{k+1}^T S_{k+1}^{-1} \) Updated covariance \( P_{k+1} = \hat{P}_{k+1} - (K_{k+1} H \hat{P}_{k+1}) \) Updated state estimate \( x_{k+1} = \hat{x}_{k+1} + K_{k+1} \tilde{y}_{k+1} \). </p>
<dl class="section warning"><dt>Warning</dt><dd>this function can be called only after setting up the filter properly through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> step </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function should be once called every step, after setting up the measurement vector using <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb" title="Set measurement vector at every time step the measurement vector size and output size should match...">ekfSetMeasurementVector()</a> method </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>setting up the measurement vector everytime before calling the <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63" title="Implements the Discrete EKF update equation described by  is given by ekf_h() method innovation  inno...">ekfUpdate()</a> method is crucial, the update step is not performed if this step is skipped this is because internally a flag associated to the setting up of measurement vector is set true by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a395b24fd4ae30bb88b35179ea80117cb" title="Set measurement vector at every time step the measurement vector size and output size should match...">ekfSetMeasurementVector()</a> method which in turn is set false by <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a3511ef7000edb1af2f22c750ac5ccb63" title="Implements the Discrete EKF update equation described by  is given by ekf_h() method innovation  inno...">ekfUpdate()</a> method </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>
<p>&lt; \( z_{k+1} = h(\hat{x}_{k+1}) \)</p>
<p>&lt; \( H \mid_{x = \hat{x}_{k+1}} \)</p>
<p>&lt; innovation \( \tilde{y}_{k+1} = y_{k+1} - z_{k+1} \)</p>
<p>&lt; \( S_{k+1} = H_{k+1} \hat{P}_{k+1} H_{k+1}^T + R \)</p>
<p>&lt; \( K_{k+1} = \hat{P}_{k+1} H_{k+1}^T S_{k+1}^{-1} \)</p>
<p>&lt; \( P_{k+1} = \hat{P}_{k+1} - (K_{k+1} H \hat{P}_{k+1}) \)</p>
<p>&lt; \( x_{k+1} = \hat{x}_{k+1} + K_{k+1} \tilde{y}_{k+1} \) </p>

</div>
</div>
<a id="a37450d1833a7ce6d7b2caec4e00c9a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37450d1833a7ce6d7b2caec4e00c9a62">&#9670;&nbsp;</a></span>ekfInit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and resizes the internal buffers of this filter. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is a very crucial method of this class. This needs to be called after setting the input size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1" title="Set the input dimensions. ">ekfSetInputSize()</a>, output size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d" title="Set the ouptut dimensions. ">ekfSetOutputSize()</a> and state dimension through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a" title="Set the state dimensions. ">ekfSetStateSize()</a>, such that the corresponding matrices and vectors will resize themselves to their corresponding dimensions. Failing to do so might result in memory leaks and may cause the program to crash </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a48dda1a9c2249dc1d7d38dbc6da69b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dda1a9c2249dc1d7d38dbc6da69b8b">&#9670;&nbsp;</a></span>ekfInit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfInit </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>state_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>input_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>output_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and resizes the internal buffers of this filter. </p>
<dl class="section warning"><dt>Warning</dt><dd>this is a very crucial method of this class. This method sets the input size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a301ab496750472b1681d509e30c75da1" title="Set the input dimensions. ">ekfSetInputSize()</a>, output size through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#af8e0003290ca166251c7d8bb4a80162d" title="Set the ouptut dimensions. ">ekfSetOutputSize()</a> and state dimension through <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a47a4ba3b26206d2607d724866e4bfd1a" title="Set the state dimensions. ">ekfSetStateSize()</a> with the specified parameters, such that the corresponding matrices and vectors will resize themselves to their corresponding dimensions. Failing to do so might result in memory leaks and may cause the program to crash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state_size</td><td>state size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_size</td><td>input size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_size</td><td>output size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a236c419106fbe83a4651cdd8f28fb3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236c419106fbe83a4651cdd8f28fb3f8">&#9670;&nbsp;</a></span>ekfReset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the filter flags The filter flags check if the filter was properly initialized, if the initial state was set, if the initial state covariance was set. </p>
<p>These three flags are crucial for proper setting up of the filter. The other flags include the checks on whether the input and measurement vectors were updated at every prediction/update step </p>

</div>
</div>
<a id="a5980548288752504e9e4758b532e4c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5980548288752504e9e4758b532e4c66">&#9670;&nbsp;</a></span>ekfReset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfReset </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>state_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>input_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the filter flags, initializes and resizes internal buffers of the filter, and sets initial state, initial state covariance, and system noise and measurement noise covariance matrices. </p>
<dl class="section warning"><dt>Warning</dt><dd>size of the span for P0 and Q must be of the size (state size*state size), where * is the regular multiplication operator </dd>
<dd>
size of the span for R must be of the size (ouput size*output size), where * is the regular multiplication operator </dd>
<dd>
the matrices from the span are built in row-major ordering.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this method is particularly useful while working with hybrid systems, where the size of the system state or the measurements keep evolving with time </dd></dl>

</div>
</div>
<a id="a395b24fd4ae30bb88b35179ea80117cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395b24fd4ae30bb88b35179ea80117cb">&#9670;&nbsp;</a></span>ekfSetMeasurementVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetMeasurementVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set measurement vector at every time step the measurement vector size and output size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the measurement vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="af2ec69c3ded347027f494c84af300d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ec69c3ded347027f494c84af300d45">&#9670;&nbsp;</a></span>ekfSetInputVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetInputVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set input vector at every time step the input vector size and input size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="abcc0fd06681f866166e527abf303929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc0fd06681f866166e527abf303929e">&#9670;&nbsp;</a></span>ekfSetInitialState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetInitialState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial state the size of x0 and state size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method should be called before running the filter </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a557ecd035b2ff1e2267d3f98c0cf3a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557ecd035b2ff1e2267d3f98c0cf3a35">&#9670;&nbsp;</a></span>ekfSetStateCovariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetStateCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial state covariance matrix the size of P and (state size*state size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the state covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method should be called before running the filter </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if this matrix is not initialized properly, then the resulting output will only have NaNs in it </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a927eee549a560c68d95cbea5b0cec797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927eee549a560c68d95cbea5b0cec797">&#9670;&nbsp;</a></span>ekfSetSystemNoiseCovariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetSystemNoiseCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set system noise covariance matrix the size of Q and (state size*state size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the system noise covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>default value is a zero matrix </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a0d1bd4ba94586c78c477a4a3af1fce0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1bd4ba94586c78c477a4a3af1fce0b">&#9670;&nbsp;</a></span>ekfSetMeasurementNoiseCovariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetMeasurementNoiseCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set measurement noise covariance matrix the size of R and (output size*output size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to access the measurement noise covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>default value is a zero matrix </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a47a4ba3b26206d2607d724866e4bfd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a4ba3b26206d2607d724866e4bfd1a">&#9670;&nbsp;</a></span>ekfSetStateSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetStateSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the state dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_X</td><td>state size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this method should be called before calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a301ab496750472b1681d509e30c75da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301ab496750472b1681d509e30c75da1">&#9670;&nbsp;</a></span>ekfSetInputSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetInputSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the input dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_U</td><td>input size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this method should be called before calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="af8e0003290ca166251c7d8bb4a80162d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e0003290ca166251c7d8bb4a80162d">&#9670;&nbsp;</a></span>ekfSetOutputSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfSetOutputSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim_Y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the ouptut dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_Y</td><td>output size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this method should be called before calling <a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html#a37450d1833a7ce6d7b2caec4e00c9a62" title="Initializes and resizes the internal buffers of this filter. ">ekfInit()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a46b41687186a840fdd1b15288339c51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b41687186a840fdd1b15288339c51e">&#9670;&nbsp;</a></span>ekfGetStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfGetStates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current internal state of the filter the size of x and state size should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to copy the internal state vector into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a65ac546a68e8ee705927c5dd9b57eb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ac546a68e8ee705927c5dd9b57eb11">&#9670;&nbsp;</a></span>ekfGetStateCovariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::DiscreteExtendedKalmanFilterHelper::ekfGetStateCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get state covariance matrix the size of P and (state size*state size) should match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td><a class="el" href="classiDynTree_1_1Span.html">iDynTree::Span</a> object to copy the internal state covariance matrix onto </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true/false if successful or not </dd></dl>

</div>
</div>
<a id="a540be21bdc4ec8636da39190df3a3157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540be21bdc4ec8636da39190df3a3157">&#9670;&nbsp;</a></span>ignore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynTree::DiscreteExtendedKalmanFilterHelper::ignore </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function template to ignore unused parameters </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ExtendedKalmanFilter_8h.html">ExtendedKalmanFilter.h</a></li>
<li><a class="el" href="ExtendedKalmanFilter_8cpp.html">ExtendedKalmanFilter.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiDynTree.html">iDynTree</a></li><li class="navelem"><a class="el" href="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper.html">DiscreteExtendedKalmanFilterHelper</a></li>
    <li class="footer">Generated on Fri Jan 10 2020 08:54:56 for iDynTree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
